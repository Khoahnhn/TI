package task

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"time"

	"cve-crawler/adapter/elastic"

	"github.com/go-resty/resty/v2"
	es "gitlab.viettelcyber.com/awesome-threat/library/adapter/elastic"
	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/hash"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"gitlab.viettelcyber.com/awesome-threat/library/rest"

	"cve-crawler/defs"
	"cve-crawler/model"
)

type notify struct {
	name    string
	logger  pencil.Logger
	client  *resty.Client
	elastic elastic.EnrichmentRepository
	config  model.WorkerConfig
}

func NewNotify(conf model.WorkerConfig) Task {
	handler := &notify{name: defs.TaskNotify, config: conf}
	handler.logger, _ = pencil.New(handler.name, pencil.DebugLevel, true, os.Stdout)
	handler.client = resty.New()
	handler.client.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: false})
	handler.client.SetTimeout(time.Duration(defs.TimeoutNotify))
	handler.elastic = elastic.NewEnrichmentRepository(conf.Adapter.Elastic.Enrichment)
	// Success
	return handler
}

func (inst *notify) Start() {
	inst.Prepare()
	for {
		bts, err := ioutil.ReadFile(defs.DefaultNotifyConfigFilePath)
		if err != nil {
			inst.logger.Errorf("ioutil.ReadFile failed, reason: %v", err)
			clock.Sleep(defs.ScheduleNotify)
			continue
		}
		var config map[string]int64
		if err = json.Unmarshal(bts, &config); err != nil {
			inst.logger.Errorf("json.Unmarshal failed, reason: %v", err)
			clock.Sleep(defs.ScheduleNotify)
			continue
		}
		// Start
		last := config[defs.TypeCve]
		query := map[string]interface{}{
			"bool": map[string]interface{}{
				"filter": []interface{}{
					map[string]interface{}{
						"range": map[string]interface{}{
							"created": map[string]interface{}{
								"gt": last,
							},
						},
					},
					map[string]interface{}{
						"range": map[string]interface{}{
							"affect": map[string]interface{}{
								"gt": 0,
							},
						},
					},
				},
			},
		}
		var count int64 = 0
		count, err = inst.elastic.CVE().Count(context.Background(), query)
		if err != nil {
			inst.logger.Errorf("inst.elastic.CVE.Count failed, reason: %v", err)
			clock.Sleep(defs.ScheduleNotify)
			continue
		}
		if count == 0 {
			clock.Sleep(defs.ScheduleNotify)
			continue
		}
		documents, err := inst.elastic.CVE().Find(context.Background(), query, []string{"-created"}, 0, 1)
		if err != nil {
			if err.Error() != es.NotFoundError {
				inst.logger.Errorf("inst.elastic.CVE.Find failed, reason: %v", err)
				clock.Sleep(defs.ScheduleNotify)
				continue
			}
		}
		if len(documents) == 0 {
			inst.logger.Error("inst.elastic.CVE.Find failed, reason: not found")
			clock.Sleep(defs.ScheduleNotify)
			continue
		}
		last = documents[0].Created
		// Publish
		if err = inst.Publish(count); err != nil {
			inst.logger.Errorf("inst.Publish failed, reason: %v", err)
			continue
		}
		// Saved
		config[defs.TypeCve] = last
		f, err := os.OpenFile(defs.DefaultNotifyConfigFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
		if err != nil {
			inst.logger.Errorf("os.OpenFile failed, reason: %v", err)
			clock.Sleep(defs.ScheduleNotify)
			continue
		}
		bts, err = json.Marshal(config)
		if err != nil {
			inst.logger.Errorf("json.Marshal failed, reason: %v", err)
			clock.Sleep(defs.ScheduleNotify)
			continue
		}
		if _, err = f.Write(bts); err != nil {
			inst.logger.Errorf("f.Write failed, reason: %v", err)
			clock.Sleep(defs.ScheduleNotify)
			continue
		}
		_ = f.Close()
		// Sleep
		clock.Sleep(defs.ScheduleNotify)
	}
}

func (inst *notify) Prepare() {
	if _, err := os.Stat(defs.DefaultNotifyConfigFilePath); errors.Is(err, os.ErrNotExist) {
		f, err := os.Create(defs.DefaultNotifyConfigFilePath)
		if err != nil {
			panic(err)
		}
		if _, err = f.Write([]byte("{}")); err != nil {
			panic(err)
		}
		_ = f.Close()
	}
}

func (inst *notify) Publish(count int64) error {
	now, _ := clock.Now(clock.Local)
	title := fmt.Sprintf(defs.TitleNotify, count)
	if inst.config.App.Debug {
		title = fmt.Sprintf("[Test] %s", title)
	}
	hashTitle := hash.SHA1(title)
	body := map[string]interface{}{
		"tags":               []string{defs.TypeCve},
		"device_product":     defs.ProductName,
		"device_version":     defs.ProductVersion,
		"device_vendor":      defs.ProductVendor,
		"source_log":         defs.SourceLog,
		"rule_id":            defs.RuleID,
		"hostname":           hashTitle[:8],
		"organization_group": defs.OrganizationGroup,
		"src":                defs.URLNotify,
		"local_timestamp":    clock.Unix(now),
		"message":            title,
		"description":        fmt.Sprintf(defs.DescriptionNotify, count, defs.URLNotify),
	}
	res, err := inst.client.R().SetHeader(rest.HeaderContentType, rest.MIMEApplicationJSON).SetBody(body).Post(fmt.Sprintf(defs.URIIntegrateSIEMNotify, inst.config.Api.Integrate))
	if err != nil {
		return err
	}
	if res.StatusCode() != rest.StatusOK {
		return fmt.Errorf("response code: %d", res.StatusCode())
	}
	inst.logger.Infof("publish: %s", title)
	// Success
	return nil
}
