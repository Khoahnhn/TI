package model

import (
	"cve-crawler/defs"
	"fmt"
	"strings"
	"time"

	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/hash"
	"gitlab.viettelcyber.com/awesome-threat/library/slice"
)

type NvdCveAPI struct {
	ID      string `json:"id,omitempty" bson:"id"`
	URL     string `json:"url,omitempty" bson:"url"`
	EndTime int64  `json:"end_time,omitempty" bson:"end_time"`
}

func (doc *NvdCveAPI) GetID() interface{} {
	return doc.ID
}

type (
	CVEAPI struct {
		ID               string                 `json:"id"`
		Published        string                 `json:"published"`
		LastModified     string                 `json:"lastModified"`
		VulStatus        string                 `json:"vulnStatus"`
		SourceIdentifier string                 `json:"sourceIdentifier"`
		Descriptions     []CVEDescriptionData   `json:"descriptions"`
		Metrics          CVEAPIMetrics          `json:"metrics"`
		Configurations   []CVEAPIConfigurations `json:"configurations"`
		References       []CVEAPIReference      `json:"references"`
		Weaknesses       []CVEAPIWeaknesses     `json:"weaknesses"`
	}

	CVEAPIMetrics struct {
		MetricV40 []CVSSV40API `json:"cvssMetricV40"`
		MetricV31 []CVSSV31API `json:"cvssMetricV31"`
		MetricV30 []CVSSV31API `json:"cvssMetricV30"`
		MetricV2  []CVSSV2API  `json:"cvssMetricV2"`
	}

	CVEAPIConfigurations struct {
		Nodes []CVEAPINode `json:"nodes"`
	}

	CVEAPINode struct {
		Operator string        `json:"operator"`
		Match    []CPEAPIMatch `json:"cpeMatch"`
	}

	CVEAPIReference struct {
		Url    string   `json:"url"`
		Source string   `json:"source"`
		Tags   []string `json:"tags"`
	}

	CVEAPIWeaknesses struct {
		Source      string               `json:"source"`
		Type        string               `json:"type"`
		Description []CVEDescriptionData `json:"description"`
	}

	CPEAPIMatch struct {
		Vulnerable            bool   `json:"vulnerable"`
		Criteria              string `json:"criteria"`
		VersionStartIncluding string `json:"versionStartIncluding"`
		VersionEndIncluding   string `json:"versionEndIncluding"`
	}

	CveApiHistory struct {
		ID        string `json:"id"`
		URL       string `json:"url"`
		StartTime int64  `json:"start_time"`
		EndTime   int64  `json:"end_time"`
		Total     int    `json:"total"`
		Success   int    `json:"success"`
		Error     int    `json:"error"`
		Created   int64  `json:"created"`
	}
	CveApiHistoryLogstash struct {
		CveApiHistory
		Metadata Metadata `json:"@metadata"`
	}
)

func (doc *CVEAPI) GetLastModified() time.Time {
	modified, err := clock.ParseRFC3339(doc.LastModified)
	if err == nil {
		modified, _ := clock.InTimezone(modified, clock.Local)
		return modified
	} else {
		return time.Time{}
	}
}

func (doc *CVEAPI) GetID() string {
	// Success
	return hash.SHA1(doc.ID)
}

func (doc *CVEAPI) GetPublished() time.Time {
	published, err := clock.ParseRFC3339(doc.Published)
	if err == nil {
		published, _ = clock.InTimezone(published, clock.Local)
		return published
	} else {
		return time.Time{}
	}
}

func (doc *CVEAPI) GetProducts() []string {
	results := make([]string, 0)
	for _, conf := range doc.Configurations {
		for _, node := range conf.Nodes {
			for _, product := range node.GetProducts() {
				if !slice.String(results).Contains(product) {
					results = append(results, product)
				}
			}
		}

	}
	// Success
	return results
}

func (doc *CVEAPI) GetVendor(products []string) []string {
	vendors := make([]string, 0)
	for _, product := range products {
		cpe := strings.Split(product, ":")
		if len(cpe) >= 4 {
			vendor := strings.Title(cpe[3])
			if !slice.String(vendors).Contains(vendor) {
				vendors = append(vendors, vendor)
			}
		}
	}
	// Success
	return vendors
}

// GetLatestCVSS retrieves the latest CVSS score from the CVEAPI data, focusing on the
// given source. It will prioritize the CVSS v4 score if it exists, followed by v3 and
// v2. If no CVSS score is found, it will return the unknown severity and 0 score.
//
// Args:
//
//	source: The source type to focus on.
//
// Returns:
//
//	Severity: The severity of the CVE, mapped to the corresponding integer value.
//	Version: The version of the CVSS score.
//	Score: The score of the CVSS.
func (doc *CVEAPI) GetLatestCVSS(source defs.SourceType) (int, string, float32) {
	if ok, score40 := doc.GetCVSSV4(source); ok {
		return score40.Severity, score40.Version, score40.Score
	}
	if ok, score3 := doc.GetCVSSV3(source); ok {
		return score3.Severity, score3.Version, score3.Score
	}
	if ok, score20 := doc.GetCVSSV2(source); ok {
		return score20.Severity, score20.Version, score20.Score
	}
	severity := strings.ToLower(defs.TitleSeverityUnknown)
	// Success
	return defs.MappingSeverityToCode[severity], "", 0
}

// GetCVSSV4 retrieves the CVSS v4 metric from the CVEAPI data, focusing on the NVD
// (National Vulnerability Database) as the primary source. It iterates through the available
// CVSS v4 metrics and selects the one marked as the primary source or type. The function
// returns a boolean indicating the presence of the metric and the corresponding CVEMetric.
// If no CVSS v4 metrics are available, it returns false and nil.
func (doc *CVEAPI) GetCVSSV4(source defs.SourceType) (bool, *CVEMetric) {
	if len(doc.Metrics.MetricV40) == 0 {
		return false, nil
	}
	result := CVSSV40API{}
	for _, it := range doc.Metrics.MetricV40 {
		if source == defs.SourceTypePrimary {
			if it.Source == defs.SourceNameNVD {
				result = it
				break
			}
		} else {
			if it.Source != defs.SourceNameNVD {
				result = it
				break
			}
		}
	}
	if result.CVSSData.Version == "" {
		return false, nil
	}
	severity := strings.ToLower(result.CVSSData.BaseSeverity)
	metric := &CVEMetric{
		Version:  result.CVSSData.Version,
		Severity: defs.MappingSeverityToCode[severity],
		Score:    result.CVSSData.BaseScore,
	}
	// Success
	return true, metric
}

// GetCVSSV3 retrieves the CVSS v3.1 metric from the CVEAPI data, focusing on the NVD
// (National Vulnerability Database) as the primary source. It iterates through the available
// CVSS v3.1 metrics and selects the one marked as the primary source or type. The function
// returns a boolean indicating the presence of the metric and the corresponding CVEMetric.
// If no CVSS v3.1 metrics are available, it returns false and nil.
func (doc *CVEAPI) GetCVSSV3(source defs.SourceType) (bool, *CVEMetric) {
	if len(doc.Metrics.MetricV31) == 0 && len(doc.Metrics.MetricV30) == 0 {
		return false, nil
	}
	metricV3 := doc.Metrics.MetricV31
	if len(doc.Metrics.MetricV31) == 0 {
		metricV3 = doc.Metrics.MetricV30
	}

	result := CVSSV31API{}
	for _, it := range metricV3 {
		if source == defs.SourceTypePrimary {
			if it.Source == defs.SourceNameNVD {
				result = it
				break
			}
		} else {
			if it.Source != defs.SourceNameNVD {
				result = it
				break
			}
		}
	}
	if result.Vector.Version == "" {
		return false, nil
	}
	severity := strings.ToLower(result.Vector.BaseSeverity)
	metric := &CVEMetric{
		Version:  result.Vector.Version,
		Severity: defs.MappingSeverityToCode[severity],
		Score:    result.Vector.BaseScore,
	}
	// Success
	return true, metric
}

// GetCVSSV2 retrieves the CVSS v2 metric from the CVEAPI data, focusing on the NVD
// (National Vulnerability Database) as the primary source. It iterates through the available
// CVSS v2 metrics and selects the one marked as the primary source or type. The function
// returns a boolean indicating the presence of the metric and the corresponding CVEMetric.
// If no CVSS v2 metrics are available, it returns false and nil.
func (doc *CVEAPI) GetCVSSV2(source defs.SourceType) (bool, *CVEMetric) {
	if len(doc.Metrics.MetricV2) == 0 {
		return false, nil
	}
	result := CVSSV2API{}
	for _, it := range doc.Metrics.MetricV2 {
		if source == defs.SourceTypePrimary {
			if it.Source == defs.SourceNameNVD {
				result = it
				break
			}
		} else {
			if it.Source != defs.SourceNameNVD {
				result = it
				break
			}
		}
	}
	if result.Vector.Version == "" {
		return false, nil
	}
	severity := strings.ToLower(result.Severity)
	metric := &CVEMetric{
		Version:  result.Vector.Version,
		Severity: defs.MappingSeverityToCode[severity],
		Score:    result.Vector.BaseScore,
	}
	return true, metric
}

func (doc *CVEAPI) GetDescriptions() []string {
	descriptions := make([]string, 0)
	for _, description := range doc.Descriptions {
		if description.Lang != defs.LangEn {
			continue
		}
		descriptions = append(descriptions, description.Value)
	}
	// Success
	return descriptions
}
func (doc *CVEAPI) GetReference() []string {
	references := make([]string, 0)
	for _, reference := range doc.References {
		if len(reference.Tags) > 0 {
			references = append(references, fmt.Sprintf("%v %s", reference.Tags, reference.Url))
		} else {
			references = append(references, reference.Url)
		}
	}
	// Success
	return references
}

func (doc *CVEAPI) GetPatch() []string {
	patchs := make([]string, 0)
	for _, reference := range doc.References {
		if len(reference.Tags) > 0 {
			if slice.String(reference.Tags).Contains("Patch") {
				patchs = append(patchs, reference.Url)
			}
		}
	}
	// Success
	return patchs
}
func (doc *CVEAPINode) GetProducts() []string {
	results := make([]string, 0)
	for _, node := range doc.Match {
		results = append(results, node.Criteria)
	}
	return results
}

// VulnerabilityToCVERaw converts a CVEAPI to a CVERaw.
//
// It translates the data from the CVE API to the CVERaw struct.
//
// It returns the converted CVERaw or an error if the conversion failed.
func (doc *CVEAPI) VulnerabilityToCVERaw() (cve CVERaw) {
	nodes := make([]CVENode, 0)
	for _, conf := range doc.Configurations {
		for _, node := range conf.Nodes {
			matches := make([]CPEMatch, 0)
			for _, match := range node.Match {
				m := CPEMatch{
					Vulnerable: match.Vulnerable,
					Cpe23Uri:   match.Criteria,
				}
				if m.Vulnerable {
					m.VersionStartIncluding = match.VersionStartIncluding
					m.VersionEndIncluding = match.VersionEndIncluding
				} else {
					m.VersionStartExcluding = match.VersionStartIncluding
					m.VersionEndExcluding = match.VersionEndIncluding
				}
				matches = append(matches, m)
			}
			nodes = append(nodes, CVENode{
				Operator: node.Operator,
				Match:    matches,
			})
		}
	}
	metricV4 := CVSSV40API{}
	metricV3 := CVSSV31API{}
	metricV2 := CVSSV2API{}
	cnaMetricV4 := CVSSV40API{}
	cnaMetricV3 := CVSSV31API{}
	cnaMetricV2 := CVSSV2API{}
	// Check CVSS v4.0
	if len(doc.Metrics.MetricV40) != 0 {
		// GET NVD
		for _, it := range doc.Metrics.MetricV40 {
			if it.Source == defs.SourceNameNVD {
				metricV4 = it
				break
			}
		}
		// GET CNA
		for _, it := range doc.Metrics.MetricV40 {
			if it.Source == defs.SourceNameNVD {
				continue
			}
			if it.Type == defs.SourceTypePrimary {
				cnaMetricV4 = it
				break
			}
			if it.Type == defs.SourceTypeSecondary {
				cnaMetricV4 = it
				continue
			}
		}
	}
	// Check CVSS v3.1
	if len(doc.Metrics.MetricV31) != 0 {
		// GET NVD
		for _, it := range doc.Metrics.MetricV31 {
			if it.Source == defs.SourceNameNVD {
				metricV3 = it
				break
			}
		}
		// GET CNA
		for _, it := range doc.Metrics.MetricV31 {
			if it.Source == defs.SourceNameNVD {
				continue
			}
			if it.Type == defs.SourceTypePrimary {
				cnaMetricV3 = it
				break
			}
			if it.Type == defs.SourceTypeSecondary {
				cnaMetricV3 = it
				continue
			}
		}
	}
	// Check CVSS v3.0
	if metricV3.Source == "" && len(doc.Metrics.MetricV30) != 0 {
		// GET NVD
		for _, it := range doc.Metrics.MetricV30 {
			if it.Source == defs.SourceNameNVD {
				metricV3 = it
				break
			}
		}
	}
	if cnaMetricV3.Source == "" && len(doc.Metrics.MetricV30) != 0 {
		// GET CNA
		for _, it := range doc.Metrics.MetricV30 {
			if it.Source == defs.SourceNameNVD {
				continue
			}
			if it.Type == defs.SourceTypePrimary {
				cnaMetricV3 = it
				break
			}
			if it.Type == defs.SourceTypeSecondary {
				cnaMetricV3 = it
				continue
			}
		}
	}

	if len(doc.Metrics.MetricV2) != 0 {
		// GET NVD
		for _, it := range doc.Metrics.MetricV2 {
			if it.Source == defs.SourceNameNVD {
				metricV2 = it
				break
			}
		}
		// GET CNA
		for _, it := range doc.Metrics.MetricV2 {
			if it.Source == defs.SourceNameNVD {
				continue
			}
			if it.Type == defs.SourceTypePrimary {
				cnaMetricV2 = it
				break
			}
			if it.Type == defs.SourceTypeSecondary {
				cnaMetricV2 = it
				continue
			}
		}
	}
	problemType := make([]CVEProblemTypeData, 0)
	for _, it := range doc.Weaknesses {
		problemType = append(problemType, CVEProblemTypeData{
			Description: it.Description,
		})
	}
	references := make([]CVEReferenceData, 0)
	for _, it := range doc.References {
		references = append(references, CVEReferenceData{
			Url:       it.Url,
			Refsource: it.Source,
			Name:      it.Url,
			Tags:      it.Tags,
		})
	}

	cve = CVERaw{
		PublishedDate:    doc.Published,
		LastModifiedDate: doc.LastModified,
		Configurations: CVEConfigurations{
			Nodes: nodes,
		},
		Impact: CVEImpact{
			MetricV4: CVSSV4{
				Vector: metricV4.CVSSData,
			},
			MetricV3: CVSSV3{
				ExploitabilityScore: metricV3.ExploitabilityScore,
				ImpactScore:         metricV3.ImpactScore,
				Vector:              metricV3.Vector,
			},
			MetricV2: CVSSV2{
				Vector:                  metricV2.Vector,
				Severity:                metricV2.Severity,
				ExploitabilityScore:     metricV2.ExploitabilityScore,
				ImpactScore:             metricV2.ImpactScore,
				AcInsufInfo:             metricV2.AcInsufInfo,
				ObtainAllPrivilege:      metricV2.ObtainAllPrivilege,
				ObtainUserPrivilege:     metricV2.ObtainUserPrivilege,
				ObtainOtherPrivilege:    metricV2.ObtainOtherPrivilege,
				UserInteractionRequired: metricV2.UserInteractionRequired,
			},
			MetricCNAV4: CVSSV4{
				Vector: cnaMetricV4.CVSSData,
			},
			MetricCNAV3: CVSSV3{
				ExploitabilityScore: cnaMetricV3.ExploitabilityScore,
				ImpactScore:         cnaMetricV3.ImpactScore,
				Vector:              cnaMetricV3.Vector,
			},
			MetricCNAV2: CVSSV2{
				Vector:                  cnaMetricV2.Vector,
				Severity:                cnaMetricV2.Severity,
				ExploitabilityScore:     cnaMetricV2.ExploitabilityScore,
				ImpactScore:             cnaMetricV2.ImpactScore,
				AcInsufInfo:             cnaMetricV2.AcInsufInfo,
				ObtainAllPrivilege:      cnaMetricV2.ObtainAllPrivilege,
				ObtainUserPrivilege:     cnaMetricV2.ObtainUserPrivilege,
				ObtainOtherPrivilege:    cnaMetricV2.ObtainOtherPrivilege,
				UserInteractionRequired: cnaMetricV2.UserInteractionRequired,
			},
		},
		Detail: CVEDetail{
			Metadata: CVEMetadata{
				ID:       doc.ID,
				Assigner: doc.SourceIdentifier,
			},
			ProblemType: CVEProblemType{
				Data: problemType,
			},
			References: CVEReference{
				Data: references,
			},
			Description: CVEDescription{
				Data: doc.Descriptions,
			},
		},
	}
	// Success
	return
}
