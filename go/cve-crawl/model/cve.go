package model

import (
	"fmt"
	"strings"
	"time"

	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/hash"
	"gitlab.viettelcyber.com/awesome-threat/library/slice"

	"cve-crawler/defs"
)

type (
	CVE struct {
		EID           string            `json:"-"`
		ID            string            `json:"id"`
		Name          string            `json:"name"`
		Created       int64             `json:"created"`
		Modified      int64             `json:"modified"`
		Latest        int64             `json:"latest"`
		Published     int64             `json:"published"`
		Crawled       int64             `json:"crawled"`
		Vendor        []string          `json:"vendor"`
		Customer      []string          `json:"customer"`
		Affect        int64             `json:"affect"`
		Match         []string          `json:"match"`
		Status        int               `json:"status"`
		Score         CVEScore          `json:"score"`
		Checker       string            `json:"checker"`
		Checklist     CVEChecklist      `json:"checklist"`
		Languages     []string          `json:"languages"`
		Searchable    CVESearchable     `json:"searchable"`
		IsRecheck     bool              `json:"isRecheck"`
		Approved      int64             `json:"approved"`
		ApprovedFirst int64             `json:"approved_first"`
		AnalysisTime  int64             `json:"analysis_time"`
		CPEDetails    []CPEMatchDetail  `json:"cpe_details"`
		CPENodes      []CVENode         `json:"cpe_nodes"`
		Epss          CVEEpss           `json:"epss"`
		Cwe           []CWEMetric       `json:"cwe"`
		Organizations []CveOrganization `json:"organizations"`
		Source        string            `json:"source"`
		Creator       string            `json:"creator"`
	}

	CveOrganization struct {
		ApprovalTime int64  `json:"approval_time"`
		TenantId     string `json:"tenant_id"`
	}

	CPEMatchDetail struct {
		CPE                   string `json:"cpe"`
		VersionStartIncluding string `json:"version_start_including"`
		VersionEndIncluding   string `json:"version_end_including"`
		VersionStartExcluding string `json:"version_start_excluding"`
		VersionEndExcluding   string `json:"version_end_excluding"`
	}

	CVELang struct {
		EID         string   `json:"-"`
		ID          string   `json:"id"`
		Lang        string   `json:"lang"`
		Description string   `json:"description"`
		Raw         string   `json:"raw"`
		Reference   []string `json:"reference"`
		Patch       []string `json:"patch"`
	}

	CVESearchable struct {
		EN CVESearch `json:"en"`
		VI CVESearch `json:"vi"`
	}

	CVESearch struct {
		Description string   `json:"description"`
		Reference   []string `json:"reference"`
	}

	CVEScore struct {
		Global CVEMetric `json:"global"`
		CVSS2  CVEMetric `json:"cvss_v2"`
		CVSS3  CVEMetric `json:"cvss_v3"`
		CVSS4  CVEMetric `json:"cvss_v4"`
		CNA    CVEMetric `json:"cna"`
		VTI    CVEMetric `json:"vti"`
	}

	CVEChecklist struct {
		Metric CVECheckListMetric `json:"metric"`
		Point  int                `json:"point"`
	}

	CVECheckListMetric struct {
		Affect    int `json:"affect"`
		Exploit   int `json:"exploit"`
		Patch     int `json:"patch"`
		Ability   int `json:"ability"`
		Condition int `json:"condition"`
	}

	CVEMetric struct {
		Score        float32 `json:"score"`
		Severity     int     `json:"severity"`
		Version      string  `json:"version"`
		VectorString string  `json:"vector_string"`
	}

	CVEConfigurations struct {
		DataVersion string    `json:"CVE_data_version"`
		Nodes       []CVENode `json:"nodes"`
	}

	CVEImpact struct {
		MetricV4    CVSSV4 `json:"baseMetricV4"`
		MetricV3    CVSSV3 `json:"baseMetricV3"`
		MetricV2    CVSSV2 `json:"baseMetricV2"`
		MetricCNAV4 CVSSV4 `json:"cnaMetricV4"`
		MetricCNAV3 CVSSV3 `json:"cnaMetricV3"`
		MetricCNAV2 CVSSV2 `json:"cnaMetricV2"`
	}

	CVENode struct {
		Operator string     `json:"operator"`
		Children []CVENode  `json:"children"`
		Match    []CPEMatch `json:"cpe_match"`
	}

	CPEMatch struct {
		Vulnerable            bool   `json:"vulnerable"`
		Cpe23Uri              string `json:"cpe23Uri"`
		VersionStartIncluding string `json:"versionStartIncluding"`
		VersionEndIncluding   string `json:"versionEndIncluding"`
		VersionStartExcluding string `json:"versionStartExcluding"`
		VersionEndExcluding   string `json:"versionEndExcluding"`
	}

	CVEDetail struct {
		DataType    string         `json:"data_type"`
		DataFormat  string         `json:"data_format"`
		DataVersion string         `json:"data_version"`
		Metadata    CVEMetadata    `json:"CVE_data_meta"`
		ProblemType CVEProblemType `json:"problemtype"`
		References  CVEReference   `json:"references"`
		Description CVEDescription `json:"description"`
	}

	CVEMetadata struct {
		ID       string `json:"ID"`
		Assigner string `json:"ASSIGNER"`
	}

	CVEProblemType struct {
		Data []CVEProblemTypeData `json:"problemtype_data"`
	}

	CVEReference struct {
		Data []CVEReferenceData `json:"reference_data"`
	}

	CVEDescriptionData struct {
		Lang  string `json:"lang"`
		Value string `json:"value"`
	}

	CVEDescription struct {
		Data []CVEDescriptionData `json:"description_data"`
	}

	CVEProblemTypeData struct {
		Description []CVEDescriptionData `json:"description"`
	}

	CVEReferenceData struct {
		Url       string   `json:"url"`
		Name      string   `json:"name"`
		Refsource string   `json:"refsource"`
		Tags      []string `json:"tags"`
	}

	CVERaw struct {
		EID              string            `json:"-"`
		Detail           CVEDetail         `json:"cve"`
		Configurations   CVEConfigurations `json:"configurations"`
		Impact           CVEImpact         `json:"impact"`
		PublishedDate    string            `json:"publishedDate"`
		LastModifiedDate string            `json:"lastModifiedDate"`
	}

	CVERawLogstash struct {
		CVERaw
		Metadata Metadata `json:"@metadata"`
	}

	CVELogstash struct {
		CVE
		Metadata Metadata `json:"@metadata"`
	}

	CVELangLogstash struct {
		CVELang
		Metadata Metadata `json:"@metadata"`
	}

	CVEEpss struct {
		Percentile *float64 `json:"percentile"`
		Score      *float64 `json:"score"`
	}

	CWEMetric struct {
		ID   string `json:"id" validate:"required"`
		Name string `json:"name"`
		Link string `json:"link" validate:"required"`
	}
)

func (doc *CVE) SetEID(id string) {
	// Success
	doc.EID = id
}

func (doc *CVE) GetID() string {
	// Success
	return doc.ID
}

func (doc *CVERaw) GetID() string {
	// Success
	return hash.SHA1(doc.Detail.Metadata.ID)
}

func (doc *CVERaw) SetEID(id string) {
	// Success
	doc.EID = id
}

func (doc *CVELang) GetID() string {
	// Success
	return doc.ID
}

func (doc *CVELang) SetEID(id string) {
	// Success
	doc.EID = id
}

func (doc *CVERaw) GetLastModified() time.Time {
	modified, err := clock.ParseRFC3339(doc.LastModifiedDate)
	if err == nil {
		modified, _ = clock.InTimezone(modified, clock.Local)
		return modified
	} else {
		return time.Time{}
	}
}

func (doc *CVERaw) GetPublished() time.Time {
	published, err := clock.ParseRFC3339(doc.PublishedDate)
	if err == nil {
		published, _ = clock.InTimezone(published, clock.Local)
		return published
	} else {
		return time.Time{}
	}
}

func (doc *CVERaw) GetDescriptions() []string {
	descriptions := make([]string, 0)
	for _, description := range doc.Detail.Description.Data {
		if description.Lang != defs.LangEn {
			continue
		}
		descriptions = append(descriptions, description.Value)
	}
	// Success
	return descriptions
}

func (doc *CVERaw) GetReference() []string {
	references := make([]string, 0)
	for _, reference := range doc.Detail.References.Data {
		if len(reference.Tags) > 0 {
			references = append(references, fmt.Sprintf("%v %s", reference.Tags, reference.Url))
		} else {
			references = append(references, reference.Url)
		}
	}
	// Success
	return references
}

func (doc *CVERaw) GetReferenceURL() []string {
	references := make([]string, 0)
	for _, reference := range doc.Detail.References.Data {
		references = append(references, reference.Url)
	}
	// Success
	return references
}

func (doc *CVERaw) GetPatch() []string {
	patchs := make([]string, 0)
	for _, reference := range doc.Detail.References.Data {
		if len(reference.Tags) > 0 {
			if slice.String(reference.Tags).Contains("Patch") {
				patchs = append(patchs, reference.Url)
			}
		}
	}
	// Success
	return patchs
}

// GetLatestCVSS retrieves the latest CVSS score from the CVE raw data, focusing on the
// given source. It will prioritize the CVSS v4 score if it exists, followed by v3 and
// v2. If no CVSS score is found, it will return the unknown severity and 0 score.
//
// Args:
//
//	source: The source type to focus on.
//
// Returns:
//
//	*CVEMetric: The corresponding CVEMetric if present, otherwise nil.
func (doc *CVERaw) GetLatestCVSS(source defs.Source) *CVEMetric {
	if ok, metric := doc.GetCVSSV4(source); ok {
		return metric
	}
	if ok, metric := doc.GetCVSSV3(source); ok {
		return metric
	}
	if ok, metric := doc.GetCVSSV2(source); ok {
		return metric
	}
	// Failed
	return &CVEMetric{Severity: defs.SeverityCodeUnknown, Version: "", Score: 0}
}

// GetCVSSV4 retrieves the CVSS v4 metric from the CVE raw data, focusing on the
// given source. It returns a boolean indicating the presence of the metric and the
// corresponding CVEMetric. If no CVSS v4 metrics are available, it returns false and
// nil.
//
// Args:
//
//	source: The source type to focus on.
//
// Returns:
//
//	bool: A boolean indicating if the CVSS v4 metric is present.
//	*CVEMetric: The corresponding CVEMetric if present, otherwise nil.
func (doc *CVERaw) GetCVSSV4(source defs.Source) (bool, *CVEMetric) {
	// NVD
	if doc.Impact.MetricV4.Vector.BaseSeverity != "" && source == defs.SourceNVD {
		severity := strings.ToLower(doc.Impact.MetricV4.Vector.BaseSeverity)
		return true, &CVEMetric{
			Severity:     defs.MappingSeverityToCode[severity],
			Version:      doc.Impact.MetricV4.Vector.Version,
			Score:        doc.Impact.MetricV4.Vector.BaseScore,
			VectorString: doc.Impact.MetricV4.Vector.VectorString,
		}
	}
	// CNA
	if doc.Impact.MetricCNAV4.Vector.BaseSeverity != "" && source == defs.SourceCNA {
		severity := strings.ToLower(doc.Impact.MetricCNAV4.Vector.BaseSeverity)
		return true, &CVEMetric{
			Severity:     defs.MappingSeverityToCode[severity],
			Version:      doc.Impact.MetricCNAV4.Vector.Version,
			Score:        doc.Impact.MetricCNAV4.Vector.BaseScore,
			VectorString: doc.Impact.MetricCNAV4.Vector.VectorString,
		}
	}
	// Failed
	return false, nil
}

// GetCVSSV3 retrieves the CVSS v3.0 metric from the CVE raw data, focusing on the NVD
// (National Vulnerability Database) as the primary source. It returns a boolean indicating
// the presence of the metric and the corresponding CVEMetric. If no CVSS v3.0 metrics are
// available, it returns false and nil.
//
// Args:
//
//	source: The source type to focus on.
//
// Returns:
//
//	bool: A boolean indicating if the CVSS v3.0 metric is present.
//	*CVEMetric: The corresponding CVEMetric if present, otherwise nil.
func (doc *CVERaw) GetCVSSV3(source defs.Source) (bool, *CVEMetric) {
	// NVD
	if doc.Impact.MetricV3.Vector.BaseSeverity != "" && source == defs.SourceNVD {
		severity := strings.ToLower(doc.Impact.MetricV3.Vector.BaseSeverity)
		return true, &CVEMetric{
			Severity:     defs.MappingSeverityToCode[severity],
			Version:      doc.Impact.MetricV3.Vector.Version,
			Score:        doc.Impact.MetricV3.Vector.BaseScore,
			VectorString: doc.Impact.MetricV3.Vector.VectorString,
		}
	}
	// CNA
	if doc.Impact.MetricCNAV3.Vector.BaseSeverity != "" && source == defs.SourceCNA {
		severity := strings.ToLower(doc.Impact.MetricCNAV3.Vector.BaseSeverity)
		return true, &CVEMetric{
			Severity:     defs.MappingSeverityToCode[severity],
			Version:      doc.Impact.MetricCNAV3.Vector.Version,
			Score:        doc.Impact.MetricCNAV3.Vector.BaseScore,
			VectorString: doc.Impact.MetricCNAV3.Vector.VectorString,
		}
	}
	// Failed
	return false, nil
}

// GetCVSSV2 retrieves the CVSS v2 metric from the CVE raw data, focusing on the NVD
// (National Vulnerability Database) as the primary source. It returns a boolean indicating
// the presence of the metric and the corresponding CVEMetric. If no CVSS v2 metrics are
// available, it returns false and nil.
//
// Args:
//
//	source: The source type to focus on.
//
// Returns:
//
//	bool: A boolean indicating if the CVSS v2 metric is present.
//	*CVEMetric: The corresponding CVEMetric if present, otherwise nil.
func (doc *CVERaw) GetCVSSV2(source defs.Source) (bool, *CVEMetric) {
	// NVD
	if doc.Impact.MetricV2.Severity != "" && source == defs.SourceNVD {
		severity := strings.ToLower(doc.Impact.MetricV2.Severity)
		return true, &CVEMetric{
			Severity:     defs.MappingSeverityToCode[severity],
			Version:      doc.Impact.MetricV2.Vector.Version,
			Score:        doc.Impact.MetricV2.Vector.BaseScore,
			VectorString: doc.Impact.MetricV2.Vector.VectorString,
		}
	}
	// CNA
	if doc.Impact.MetricCNAV2.Severity != "" && source == defs.SourceCNA {
		severity := strings.ToLower(doc.Impact.MetricCNAV2.Severity)
		return true, &CVEMetric{
			Severity:     defs.MappingSeverityToCode[severity],
			Version:      doc.Impact.MetricCNAV2.Vector.Version,
			Score:        doc.Impact.MetricCNAV2.Vector.BaseScore,
			VectorString: doc.Impact.MetricCNAV2.Vector.VectorString,
		}
	}
	// Failed
	return false, nil
}

func (doc *CVERaw) GetProducts() []string {
	results := make([]string, 0)
	for _, node := range doc.Configurations.Nodes {
		for _, product := range node.GetProducts() {
			if !slice.String(results).Contains(product) {
				results = append(results, product)
			}
		}
	}
	// Success
	return results
}

func (doc *CVENode) GetProducts() []string {
	results := make([]string, 0)
	for _, node := range doc.Match {
		results = append(results, node.Cpe23Uri)
	}
	// Recursive
	recursive := make([]string, 0)
	for _, child := range doc.Children {
		recur := child.GetProducts()
		if len(recur) != 0 {
			recursive = append(recursive, recur...)
		}
	}
	if len(recursive) == 0 {
		return results
	}
	// Success
	return append(results, recursive...)
}

func (doc *CVERaw) GetDetailProducts() []CPEMatchDetail {
	unique := make([]string, 0)
	results := make([]CPEMatchDetail, 0)
	for _, node := range doc.Configurations.Nodes {
		for _, product := range node.GetDetailProducts() {
			if !slice.String(unique).Contains(product.CPE) {
				results = append(results, product)
				unique = append(unique, product.CPE)
			}
		}
	}
	// Success
	return results
}

func (doc *CVENode) GetDetailProducts() []CPEMatchDetail {
	results := make([]CPEMatchDetail, 0)
	for _, cpeMatch := range doc.Match {
		results = append(results, CPEMatchDetail{
			CPE:                   cpeMatch.Cpe23Uri,
			VersionStartIncluding: cpeMatch.VersionStartIncluding,
			VersionEndIncluding:   cpeMatch.VersionEndIncluding,
			VersionStartExcluding: cpeMatch.VersionStartExcluding,
			VersionEndExcluding:   cpeMatch.VersionEndExcluding,
		})
	}
	recursive := make([]CPEMatchDetail, 0)
	for _, child := range doc.Children {
		recur := child.GetDetailProducts()
		if len(recur) != 0 {
			recursive = append(recursive, recur...)
		}
	}
	if len(recursive) == 0 {
		return results
	}
	// Success
	return append(results, recursive...)
}

func (doc *CVERaw) GetVendor(products []string) []string {
	vendors := make([]string, 0)
	for _, product := range products {
		cpe := strings.Split(product, ":")
		if len(cpe) >= 4 {
			vendor := strings.Title(cpe[3])
			if !slice.String(vendors).Contains(vendor) {
				vendors = append(vendors, vendor)
			}
		}
	}
	// Success
	return vendors
}

func (doc *CVE) Generate() *VulnerabilityAlert {
	now, _ := clock.Now(clock.Local)
	// Success
	return &VulnerabilityAlert{
		ID:        doc.ID,
		Name:      doc.Name,
		Modified:  clock.UnixMilli(now),
		Status:    doc.Status,
		Vendor:    doc.Vendor,
		Products:  make([]*CPEDetail, 0),
		Score:     doc.Score,
		Checklist: doc.Checklist,
		CVSS:      map[string]interface{}{},
		Languages: doc.Languages,
	}
}
