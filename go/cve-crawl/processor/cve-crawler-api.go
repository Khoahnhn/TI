package processor

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"runtime"
	"time"

	"cve-crawler/adapter/mongo"
	"cve-crawler/defs"
	"cve-crawler/model"

	"github.com/go-resty/resty/v2"
	mg "gitlab.viettelcyber.com/awesome-threat/library/adapter/mongo"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/hash"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"gitlab.viettelcyber.com/awesome-threat/library/rest"
	"golang.org/x/sync/errgroup"
)

type cveCrawlerAPI struct {
	name    string
	context context.Context
	logger  pencil.Logger
	mongo   mongo.CrawlerRepository
	queue   rabbit.Service
	config  model.WorkerConfig
	client  *resty.Client
}

func newCVECrawlerAPI(ctx context.Context, conf model.WorkerConfig) Processor {
	logger, _ := pencil.New(defs.WorkerCveCrawlerAPI, pencil.DebugLevel, true, os.Stdout)
	worker := cveCrawlerAPI{name: defs.WorkerCveCrawlerAPI, context: ctx, logger: logger, config: conf}
	// Repository
	worker.mongo = mongo.NewCrawlerRepository(worker.config.Adapter.Mongo.Crawler)
	worker.queue = rabbit.NewService(worker.context, worker.config.Adapter.Rabbit.Crawler, nil)
	// Client
	client := resty.New()
	client.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})
	client.SetTimeout(time.Duration(clock.Minute * clock.Duration(worker.config.App.Timeout)))
	if worker.config.App.Proxy.Enable {
		client.SetProxy(worker.config.App.Proxy.String())
	}
	worker.client = client
	// Success
	return &worker
}
func (worker *cveCrawlerAPI) Start() {
	// Prepare
	worker.Prepare()
	// Start
	if worker.config.App.Core == 0 {
		worker.config.App.Core = runtime.NumCPU()
	}
	group, ctx := errgroup.WithContext(worker.context)
	group.Go(func() error {
		delay := clock.Minute * clock.Duration(worker.config.App.ScheduleCrawlerAPI)
		for {
			now, _ := clock.Now(clock.UTC)
			worker.logger.Infof("[crawler]crawler cve start time: %s", now)
			config, err := worker.mongo.CVEAPIConfig().GetOne(ctx)
			if err != nil {
				if err.Error() != mg.NotFoundError {
					return err
				}
				config = model.NvdCveAPI{
					ID:      hash.SHA1(worker.config.NVDApiModified),
					URL:     worker.config.NVDApiModified,
					EndTime: now.Add(-time.Duration(clock.Day * 1)).UnixMilli(),
				}
				err = worker.mongo.CVEAPIConfig().Store(ctx, config)
				if err != nil {
					return err
				}
			}
			startTime, err := clock.ParseMilliTimestamp(config.EndTime, clock.UTC)
			if err != nil {
				worker.logger.Errorf("[crawler] parse time error: &v", err)
				break
			}
			startTime = startTime.Add(-time.Duration(worker.config.NVDApiDuration) * time.Minute)
			finished := false
			for {
				endTime := startTime.Add(time.Duration(clock.Hour * 1))
				if !endTime.Before(now) {
					endTime = now
					finished = true
				}
				worker.logger.Debugf("[crawler]crawler cve from %s to %s", startTime, endTime)
				url := fmt.Sprintf(worker.config.NVDApiModified, startTime.Format(clock.FormatRFC3339Milli), endTime.Format(clock.FormatRFC3339Milli))
				cves, err := worker.Crawl(url)
				if err != nil {
					clock.Sleep(15 * clock.Second)
					break
				}
				go worker.processData(cves, url, startTime, endTime)
				config.EndTime = endTime.UnixMilli()
				err = worker.mongo.CVEAPIConfig().UpdateOne(ctx, config)
				if err != nil {
					worker.logger.Errorf("[crawler] update nvd config api error: &v", err)
					break
				}
				if finished {
					break
				}
				startTime = endTime
				clock.Sleep(15 * clock.Second)
			}

			next := now.Add(time.Duration(delay))
			worker.logger.Infof("next time crawler: %s", clock.Format(next, clock.FormatHumanZ))
			clock.Sleep(delay)
		}
		return nil
	})
}
func (worker *cveCrawlerAPI) Prepare() {
	if err := worker.queue.DeclareQueue(defs.QueueCveMapping, true, 0, 0); err != nil {
		panic(err)
	}
}

func (worker *cveCrawlerAPI) processData(cves []CVE, url string, startTime, endTime time.Time) {
	totalData := len(cves)
	totalErr := 0
	for _, raw := range cves {
		// Send logstash-cve-raw-queue
		result := raw.CVE.VulnerabilityToCVERaw()
		meta := &model.CVERawLogstash{
			CVERaw: result,
			Metadata: model.Metadata{
				ID:    result.GetID(),
				Index: defs.IndexCVERaw,
				Type:  defs.TypeCveRaw,
			},
		}
		metaBts, _ := json.Marshal(meta)
		if err := worker.queue.Publish("", defs.QueueLogstashCveRaw, rabbit.Message{
			Body:        metaBts,
			ContentType: rabbit.MIMEApplicationJSON,
			Mode:        rabbit.Persistent,
			Priority:    0,
		}); err != nil {
			totalErr += 1
			worker.logger.Errorf("send CVE (%s) to queue(%s) error, reason: %v", result.Detail.Metadata.ID, defs.QueueLogstashCveRaw, err)
			continue
		}
		// Send logstash-cve-raw-history-queue
		meta.Metadata.ID = hash.SHA1(fmt.Sprintf("%s--%s", result.GetID(), result.LastModifiedDate))
		meta.Metadata.Index = fmt.Sprintf(defs.IndexCVERawHistory, result.LastModifiedDate[:7])
		meta.Metadata.Type = defs.TypeCveRawHistory
		metaBts, _ = json.Marshal(meta)
		if err := worker.queue.Publish("", defs.QueueLogstashCveRawHistory, rabbit.Message{
			Body:        metaBts,
			ContentType: rabbit.MIMEApplicationJSON,
			Mode:        rabbit.Persistent,
			Priority:    0,
		}); err != nil {
			totalErr += 1
			worker.logger.Errorf("send CVE (%s) to queue(%s) error, reason: %v", result.Detail.Metadata.ID, defs.QueueLogstashCveRawHistory, err)
			continue
		}
		// Send cve-parser-queue
		dataBts, _ := json.Marshal(result)
		if err := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
			Body:        dataBts,
			ContentType: rabbit.MIMEApplicationJSON,
			Mode:        rabbit.Persistent,
			Priority:    0,
		}); err != nil {
			totalErr += 1
			worker.logger.Errorf("send CVE (%s) to queue(%s) error, reason: %v", result.Detail.Metadata.ID, defs.QueueCveParser, err)
			continue
		}
	}
	history := model.CveApiHistoryLogstash{
		CveApiHistory: model.CveApiHistory{
			ID:        hash.SHA1(url),
			URL:       url,
			StartTime: startTime.UnixMilli(),
			EndTime:   endTime.UnixMilli(),
			Total:     totalData,
			Success:   totalData,
			Error:     totalErr,
			Created:   time.Now().UTC().UnixMilli(),
		},
		Metadata: model.Metadata{
			ID:    hash.SHA1(url),
			Index: defs.IndexCVEApiHistory,
			Type:  defs.TypeCveApiHistory,
		},
	}
	metaBts, _ := json.Marshal(history)
	if err := worker.queue.Publish("", defs.QueueCveApiHistory, rabbit.Message{
		Body:        metaBts,
		ContentType: rabbit.MIMEApplicationJSON,
		Mode:        rabbit.Persistent,
		Priority:    0,
	}); err != nil {
		worker.logger.Errorf("send CVE api history (%s) to queue(%s) error, reason: %v", history.ID, defs.QueueCveApiHistory, err)
	}
}

func (worker *cveCrawlerAPI) Crawl(url string) ([]CVE, error) {
	totalResult := 2000
	startIndex := 0
	result := make([]CVE, 0)
	retry := 0
	api := "%s&startIndex=%d"

	for {
		if startIndex >= totalResult {
			break
		}

		cve, err := worker.GetCVE(fmt.Sprintf(api, url, startIndex))
		if err != nil {
			worker.logger.Errorf("[crawler] get cves [%s] error: %v", fmt.Sprintf(api, url, startIndex), err)
			retry++
			if retry > 5 {
				return result, err
			}
			break
		}
		retry = 0

		result = append(result, cve.Vulnerabilities...)
		startIndex = cve.StartIndex + cve.ResultsPerPage
		totalResult = cve.TotalResults

		clock.Sleep(15 * clock.Second)
	}

	return result, nil
}

func (worker *cveCrawlerAPI) GetCVE(url string) (*CVEResponse, error) {
	res, err := worker.client.R().
		SetHeader("apiKey", worker.config.NVDKey).
		Get(url)
	worker.logger.Infof("start crawl %s", url)
	if err != nil {
		worker.logger.Errorf("get url (%s) error, reason: %v", worker.config.NVDApi, err)
		return nil, err
	}
	if res.StatusCode() != rest.StatusOK {
		worker.logger.Errorf("get url (%s) return code %d", url, res.StatusCode())
		return nil, errors.New(fmt.Sprintf("status code: %d", res.StatusCode()))
	}

	var cve CVEResponse
	err = json.Unmarshal(res.Body(), &cve)
	if err != nil {
		worker.logger.Errorf("Unmarshal cve error, reason: %v", err)
		return nil, err
	}

	return &cve, nil
}

type CVECrawlerResponse struct {
	Vulnerabilities []CVE `json:"vulnerabilities"`
}
