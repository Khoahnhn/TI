package processor

import (
	"context"
	"encoding/json"
	"os"
	"runtime"
	"strings"
	"sync"

	"cve-crawler/adapter/elastic"

	es "gitlab.viettelcyber.com/awesome-threat/library/adapter/elastic"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/redis"
	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/core/cpe"
	"gitlab.viettelcyber.com/awesome-threat/library/hash"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"gitlab.viettelcyber.com/awesome-threat/library/slice"
	"golang.org/x/sync/errgroup"

	"cve-crawler/defs"
	"cve-crawler/model"
)

type cveMapping struct {
	name    string
	context context.Context
	logger  pencil.Logger
	elastic elastic.Repository
	queue   rabbit.Service
	cache   redis.Service
	mutex   *sync.Mutex
	config  model.WorkerConfig
}

func newCveMapping(ctx context.Context, conf model.WorkerConfig) Processor {
	logger, _ := pencil.New(defs.WorkerCveMapping, pencil.DebugLevel, true, os.Stdout)
	worker := cveMapping{name: defs.WorkerCveMapping, logger: logger, mutex: &sync.Mutex{}, config: conf}
	// Repository
	worker.elastic = elastic.NewRepository(worker.config.Adapter.Elastic)
	worker.queue = rabbit.NewService(worker.context, worker.config.Adapter.Rabbit.Crawler, nil)
	worker.cache = redis.NewService(worker.config.Adapter.Redis.General, nil)
	// Success
	return &worker
}

func (worker *cveMapping) Start() {
	// Prepare
	worker.Prepare()
	if worker.config.App.Core == 0 {
		worker.config.App.Core = runtime.NumCPU()
	}
	// Start
	group, ctx := errgroup.WithContext(worker.context)
	// Mapping
	group.Go(func() error {
		query := map[string]interface{}{
			"bool": map[string]interface{}{
				"should": []interface{}{
					map[string]interface{}{
						"term": map[string]interface{}{
							"status": defs.StatusCodeUnknown,
						},
					},
					map[string]interface{}{
						"term": map[string]interface{}{
							"status": defs.StatusCodeNew,
						},
					},
					map[string]interface{}{
						"term": map[string]interface{}{
							"status": defs.StatusCodeWaitApprove,
						},
					},
				},
			},
		}
		for {
			documents, err := worker.elastic.Enrichment().CVE().FindAll(ctx, query, []string{})
			if err != nil {
				if err.Error() == es.NotFoundError {
					return err
				}
				documents = make([]*model.CVE, 0)
			}
			for _, document := range documents {
				if len(document.Match) > 0 {
					if err = worker.cache.Strings().Set(document.Name, strings.Join(document.Match, ";"), 0); err != nil {
						worker.logger.Errorf("failed to cache CVE(%s), reason: %v", document.Name, err)
						continue
					}
				}
			}
			clock.Sleep(clock.Minute * 15)
		}
	})
	clock.Sleep(clock.Second * 15)
	// Consume
	for i := 0; i < worker.config.App.Core; i++ {
		queue := rabbit.NewService(ctx, worker.config.Adapter.Rabbit.Crawler, nil)
		group.Go(func() error {
			err := queue.Consume(defs.QueueCveMapping, true, 1, func(data []byte) error {
				var asset model.AssetMapping
				if err := json.Unmarshal(data, &asset); err != nil {
					return worker.HandleError(err, data)
				}
				worker.logger.Infof("process assets (%d) for organization: %s", len(asset.Assets), asset.Organization)
				documents, err := worker.cache.Keys().All()
				if err != nil {
					return worker.HandleError(err, data)
				}
				for _, document := range documents {
					match := false
					product, err := worker.cache.Strings().Get(document)
					if err != nil {
						worker.logger.Errorf("failed to get (%s) in cache, reason: %v", document, err)
						continue
					}
					products := strings.Split(product, ";")
					for _, pro := range products {
						actual, err := cpe.NewItemFromFormattedString(pro)
						if err != nil {
							worker.logger.Errorf("failed to parse cpe (%s), reason: %v", pro, err)
							continue
						}
						for _, ac := range asset.Assets {
							value, err := cpe.NewItemFromFormattedString(ac)
							if err != nil {
								worker.logger.Errorf("failed to parse cpe (%s), reason: %v", ac, err)
								continue
							}
							if cpe.CheckSubset(value, actual, true) || cpe.CheckSuperset(value, actual, true) {
								match = true
								break
							}
						}
					}
					if match {
						cve, err := worker.elastic.Enrichment().CVE().GetByID(ctx, hash.SHA1(document))
						if err != nil {
							worker.logger.Errorf("failed to get cve (%s), reason: %v", document, err)
							continue
						}
						if !slice.String(cve.Customer).Contains(asset.Organization) {
							cve.Customer = append(cve.Customer, asset.Organization)
						}
						cve.Affect = int64(len(cve.Customer))
						if err = worker.elastic.Enrichment().CVE().Store(ctx, cve); err != nil {
							worker.logger.Errorf("failed to update cve (%s), reason: %v", document, err)
							continue
						}
					}
				}
				return nil
			})
			// Success
			return err
		})
	}

	select {}
}

func (worker *cveMapping) HandleError(err error, bts []byte) error {
	worker.logger.Errorf("process CVE error, reason: %v", err)
	// Success
	return nil
}

func (worker *cveMapping) Prepare() {
	if err := worker.queue.DeclareQueue(defs.QueueCveMapping, true, 0, 0); err != nil {
		panic(err)
	}
}
