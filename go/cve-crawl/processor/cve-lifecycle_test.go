package processor

import (
	"bytes"
	"context"
	"cve-crawler/defs"
	"cve-crawler/mocks"
	"cve-crawler/model"
	"encoding/json"
	"errors"
	"io"
	"log"
	"net/http"
	"os"
	"sync"
	"testing"

	"github.com/go-resty/resty/v2"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"go.uber.org/mock/gomock"
	"gopkg.in/yaml.v2"
)

type response struct {
	Code    int
	Message string
}

type fakeTransport struct {
	Code    int
	Message string
	ResMap  map[string]response
}

func (t *fakeTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	log.Print(req.RequestURI)
	if res, ok := t.ResMap[req.RequestURI]; ok {
		return &http.Response{
			StatusCode: t.Code,
			Body:       io.NopCloser(bytes.NewBufferString(res.Message)),
			Header:     make(http.Header),
		}, nil
	}
	// Create a fake response
	body := io.NopCloser(bytes.NewBufferString(t.Message))
	return &http.Response{
		StatusCode: t.Code,
		Body:       body,
		Header:     make(http.Header),
	}, nil
}

func Test_cveLifecycle_Start(t *testing.T) {
	ctrl := gomock.NewController(t)
	logger, _ := pencil.New(defs.WorkerCveParser, pencil.DebugLevel, false, os.Stdout)

	tests := []struct {
		name   string
		worker *cveLifecycle
	}{
		{
			name: "base_case",
			worker: func() *cveLifecycle {
				ctx, cancel := context.WithCancel(context.Background())

				mockRabbit := mocks.NewMockService(ctrl)
				mockRabbit.EXPECT().DeclareQueue(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(nil)
				mockRabbit.EXPECT().Consume(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Do(func(queue string, auto bool, prefetchCount int, callback rabbit.Consumer) {
						callback([]byte(""))
						cancel()
					}).
					Return(nil)

				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code: 403,
				}) // inject fake transport
				return &cveLifecycle{
					context: ctx,
					queue:   mockRabbit,
					client:  mockResty,
				}
			}(),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.worker.logger = logger
			tt.worker.mutex = &sync.Mutex{}
			tt.worker.Start()
		})
	}
}

func Test_cveLifecycle_handleCveOrg(t *testing.T) {
	// err := errors.New("foo")
	logger, _ := pencil.New(defs.WorkerCveParser, pencil.DebugLevel, false, os.Stdout)
	eventsChan := make(chan *model.CVELifecycle, 1000)
	conf := model.WorkerConfig{
		CveorgCveApi: "http://example.com/%v",
	}
	tests := []struct {
		name    string
		worker  *cveLifecycle
		wantErr bool
	}{
		{
			name: "base_case",
			worker: func() *cveLifecycle {

				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code: 403,
				}) // inject fake transport

				return &cveLifecycle{
					logger: logger,
					client: mockResty,
				}
			}(),
			wantErr: true,
		},
		{
			name: "bad_time_case",
			worker: func() *cveLifecycle {
				response := model.CveorgCveApiResponse{
					CveMetadata: model.CveorgCveMetadata{
						DatePublished: "malformed",
					},
				}
				msg, _ := json.Marshal(response)

				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    403,
					Message: string(msg),
				}) // inject fake transport

				return &cveLifecycle{
					logger: logger,
					client: mockResty,
				}
			}(),
			wantErr: false,
		},
		{
			name: "happy_case",
			worker: func() *cveLifecycle {
				response := model.CveorgCveApiResponse{
					CveMetadata: model.CveorgCveMetadata{
						DatePublished: "2011-11-11T11:11:11.000Z",
					},
					Containers: model.CveorgDataContainers{
						Adp: []model.CveorgAdpContainer{
							{
								Metrics: []model.CveorgAdpMetric{
									{
										Other: model.CveorgAdpMetricOther{
											Type: "some",
										},
									},
									{
										Other: model.CveorgAdpMetricOther{
											Type: "kev",
											Content: map[string]any{
												"dateAdded": "2011-11-11",
											},
										},
									},
								},
							},
						},
					},
				}
				msg, _ := json.Marshal(response)

				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    403,
					Message: string(msg),
				}) // inject fake transport

				return &cveLifecycle{
					logger: logger,
					client: mockResty,
				}
			}(),
			wantErr: false,
		},
		{
			name: "bad_kev_case",
			worker: func() *cveLifecycle {
				response := model.CveorgCveApiResponse{
					CveMetadata: model.CveorgCveMetadata{
						DatePublished: "2011-11-11T11:11:11.000Z",
					},
					Containers: model.CveorgDataContainers{
						Adp: []model.CveorgAdpContainer{
							{
								Metrics: []model.CveorgAdpMetric{
									{
										Other: model.CveorgAdpMetricOther{
											Type: "some",
										},
									},
									{
										Other: model.CveorgAdpMetricOther{
											Type: "kev",
											Content: map[string]any{
												"dateAdde": "2011-11-11T11:11:11.000Z",
											},
										},
									},
								},
							},
						},
					},
				}
				msg, _ := json.Marshal(response)

				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    403,
					Message: string(msg),
				}) // inject fake transport

				return &cveLifecycle{
					logger: logger,
					client: mockResty,
				}
			}(),
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.worker.config = conf
			if err := tt.worker.handleCveOrg(context.Background(), "CVE-0-0", eventsChan); (err != nil) != tt.wantErr {
				t.Errorf("cveLifecycle.handleCveOrg() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_newCveLifecycle(t *testing.T) {

	var config model.WorkerConfig
	f, err := os.Open("../config-dev.yaml")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	decoder := yaml.NewDecoder(f)
	err = decoder.Decode(&config)
	if err != nil {
		panic(err)
	}
	newCveLifecycleV2(context.TODO(), config)

}

func Test_cveLifecycle_handleCveEpssHistory(t *testing.T) {
	ctrl := gomock.NewController(t)
	err := errors.New("foo")
	logger, _ := pencil.New(defs.WorkerCveParser, pencil.DebugLevel, false, os.Stdout)
	config := model.WorkerConfig{
		FirstCveEpssAPI: "https://example.com",
	}
	tests := []struct {
		name    string
		worker  *cveLifecycle
		wantErr bool
		cve     string
	}{
		{
			name: "bad_url_case",
			worker: func() *cveLifecycle {
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    403,
					Message: "",
				}) // inject fake transport
				return &cveLifecycle{
					client: mockResty,
				}
			}(),
			wantErr: true,
			cve:     "\\nCVE-0-0",
		},
		{
			name: "no_entry_case",
			worker: func() *cveLifecycle {
				response := model.FirstOrgCveEpssResponse{
					Total: 0,
				}
				bts, _ := json.Marshal(response)
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    200,
					Message: string(bts),
				}) // inject fake transport
				return &cveLifecycle{
					client: mockResty,
				}
			}(),
			wantErr: true,
			cve:     "CVE-0-0",
		},
		{
			name: "fail_es_case",
			worker: func() *cveLifecycle {
				response := model.FirstOrgCveEpssResponse{
					Total: 1,
					Data: []*model.FirstOrgCveEpssData{
						{
							Cve:        "CVE-0-0",
							Epss:       "0.1",
							Percentile: "0.1",
						},
					},
				}
				bts, _ := json.Marshal(response)
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    200,
					Message: string(bts),
				}) // inject fake transport

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)
				mockEs.EXPECT().CVE().Return(mockCve).AnyTimes()

				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).AnyTimes().Return(nil, err)

				return &cveLifecycle{
					client:  mockResty,
					elastic: mockEs,
				}
			}(),
			wantErr: true,
			cve:     "CVE-0-0",
		},
		{
			name: "fail_score_case",
			worker: func() *cveLifecycle {
				response := model.FirstOrgCveEpssResponse{
					Total: 1,
					Data: []*model.FirstOrgCveEpssData{
						{
							Cve:        "CVE-0-0",
							Epss:       "abc",
							Percentile: "0.1",
						},
					},
				}
				bts, _ := json.Marshal(response)
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    200,
					Message: string(bts),
				}) // inject fake transport

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)
				mockEs.EXPECT().CVE().Return(mockCve).AnyTimes()

				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).AnyTimes().Return(nil, err)

				return &cveLifecycle{
					client:  mockResty,
					elastic: mockEs,
				}
			}(),
			wantErr: true,
			cve:     "CVE-0-0",
		},
		{
			name: "fail_percentile_case",
			worker: func() *cveLifecycle {
				response := model.FirstOrgCveEpssResponse{
					Total: 1,
					Data: []*model.FirstOrgCveEpssData{
						{
							Cve:        "CVE-0-0",
							Epss:       "0.1",
							Percentile: "abc",
						},
					},
				}
				bts, _ := json.Marshal(response)
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    200,
					Message: string(bts),
				}) // inject fake transport

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)
				mockEs.EXPECT().CVE().Return(mockCve).AnyTimes()

				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).AnyTimes().Return(nil, err)

				return &cveLifecycle{
					client:  mockResty,
					elastic: mockEs,
				}
			}(),
			wantErr: true,
			cve:     "\\nCVE-0-0",
		},
		{
			name: "same_score_case",
			worker: func() *cveLifecycle {
				response := model.FirstOrgCveEpssResponse{
					Total: 1,
					Data: []*model.FirstOrgCveEpssData{
						{
							Cve:        "CVE-0-0",
							Epss:       "0.1",
							Percentile: "0.1",
						},
					},
				}
				bts, _ := json.Marshal(response)
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    200,
					Message: string(bts),
				}) // inject fake transport

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)
				mockEs.EXPECT().CVE().Return(mockCve).AnyTimes()

				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).AnyTimes().
					Return(&model.CVE{
						Epss: model.CVEEpss{
							Score: nil,
						},
					}, nil)

				return &cveLifecycle{
					client:  mockResty,
					elastic: mockEs,
				}
			}(),
			wantErr: false,
			cve:     "CVE-0-0",
		},
		{
			name: "fail_insert_case",
			worker: func() *cveLifecycle {
				response := model.FirstOrgCveEpssResponse{
					Total: 1,
					Data: []*model.FirstOrgCveEpssData{
						{
							Cve:        "CVE-0-0",
							Epss:       "0.1",
							Percentile: "0.1",
						},
					},
				}
				bts, _ := json.Marshal(response)
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    200,
					Message: string(bts),
				}) // inject fake transport

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)
				mockEs.EXPECT().CVE().Return(mockCve).AnyTimes()

				score := 0.2
				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).AnyTimes().
					Return(&model.CVE{
						Epss: model.CVEEpss{
							Score: &score,
						},
					}, nil)

				mockCve.EXPECT().UpdateMany(gomock.Any(), gomock.Any()).
					Return(err).AnyTimes()

				return &cveLifecycle{
					client:  mockResty,
					elastic: mockEs,
				}
			}(),
			wantErr: true,
			cve:     "CVE-0-0",
		},
		{
			name: "fail_insert_history_case",
			worker: func() *cveLifecycle {
				response := model.FirstOrgCveEpssResponse{
					Total: 1,
					Data: []*model.FirstOrgCveEpssData{
						{
							Cve:        "CVE-0-0",
							Epss:       "0.1",
							Percentile: "0.1",
						},
					},
				}
				bts, _ := json.Marshal(response)
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    200,
					Message: string(bts),
				}) // inject fake transport

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)
				mockEs.EXPECT().CVE().Return(mockCve).AnyTimes()

				score := 0.2
				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).AnyTimes().
					Return(&model.CVE{
						Epss: model.CVEEpss{
							Score: &score,
						},
					}, nil)

				mockCve.EXPECT().UpdateMany(gomock.Any(), gomock.Any()).
					Return(nil).AnyTimes()

				mockEpssHistory := mocks.NewMockCVEEpssHistoryRepository(ctrl)
				mockEs.EXPECT().CVEEpssHistory().Return(mockEpssHistory).AnyTimes()

				mockEpssHistory.EXPECT().Store(gomock.Any(), gomock.Any()).Return(err).AnyTimes()

				return &cveLifecycle{
					client:  mockResty,
					elastic: mockEs,
				}
			}(),
			wantErr: true,
			cve:     "CVE-0-0",
		},
		{
			name: "happy_case",
			worker: func() *cveLifecycle {
				response := model.FirstOrgCveEpssResponse{
					Total: 1,
					Data: []*model.FirstOrgCveEpssData{
						{
							Cve:        "CVE-0-0",
							Epss:       "0.1",
							Percentile: "0.1",
						},
					},
				}
				bts, _ := json.Marshal(response)
				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransport{
					Code:    200,
					Message: string(bts),
				}) // inject fake transport

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)
				mockEs.EXPECT().CVE().Return(mockCve).AnyTimes()

				score := 0.2
				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).AnyTimes().
					Return(&model.CVE{
						Epss: model.CVEEpss{
							Score: &score,
						},
					}, nil)

				mockCve.EXPECT().UpdateMany(gomock.Any(), gomock.Any()).
					Return(nil).AnyTimes()

				mockEpssHistory := mocks.NewMockCVEEpssHistoryRepository(ctrl)
				mockEs.EXPECT().CVEEpssHistory().Return(mockEpssHistory).AnyTimes()

				mockEpssHistory.EXPECT().Store(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()

				return &cveLifecycle{
					client:  mockResty,
					elastic: mockEs,
				}
			}(),
			wantErr: false,
			cve:     "CVE-0-0",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.worker.logger = logger
			tt.worker.config = config
			if err := tt.worker.handleCveEpssHistory(tt.cve, context.Background()); (err != nil) != tt.wantErr {
				t.Errorf("cveLifecycle.handleCveEpssHistory() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
