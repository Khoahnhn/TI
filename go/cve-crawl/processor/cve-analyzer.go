package processor

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"runtime"
	"strings"
	"sync"
	"time"

	"cve-crawler/adapter/elastic"
	"cve-crawler/adapter/mongo"
	"cve-crawler/defs"
	"cve-crawler/model"

	es "gitlab.viettelcyber.com/awesome-threat/library/adapter/elastic"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"gitlab.viettelcyber.com/awesome-threat/library/arrayx"
	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/core/cpe"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"gitlab.viettelcyber.com/awesome-threat/library/tld"
	"go.mongodb.org/mongo-driver/bson"
	"golang.org/x/sync/errgroup"
)

type cveAnalyzer struct {
	name    string
	context context.Context
	logger  pencil.Logger
	tld     tld.Service
	elastic elastic.Repository
	mongo   mongo.AccountRepository
	queue   rabbit.Service
	config  model.WorkerConfig
	mutex   *sync.Mutex
}

func newCveAnalyzer(ctx context.Context, conf model.WorkerConfig) Processor {
	logger, _ := pencil.New(defs.WorkerCveAnalyzer, pencil.DebugLevel, true, os.Stdout)
	worker := cveAnalyzer{name: defs.WorkerCveAnalyzer, context: ctx, logger: logger, mutex: &sync.Mutex{}, config: conf}
	if worker.config.App.Core == 0 {
		worker.config.App.Core = runtime.NumCPU()
	}
	if worker.config.App.ReferenceVendors == nil {
		worker.config.App.ReferenceVendors = make([]string, 0)
	}
	// Repository
	worker.elastic = elastic.NewRepository(worker.config.Adapter.Elastic)
	worker.mongo = mongo.NewAccountRepository(worker.config.Adapter.Mongo.Account)
	worker.queue = rabbit.NewService(worker.context, worker.config.Adapter.Rabbit.Crawler, nil)
	// TLD
	tldCacheFile := os.Getenv(defs.EnvTLDCacheFilePath)
	if tldCacheFile == "" {
		tldCacheFile = defs.DefaultTLDCacheFilePath
	}
	worker.tld = tld.NewService(tldCacheFile)
	// Success
	return &worker
}

func (worker *cveAnalyzer) Start() {
	// Prepare
	worker.Prepare()
	// Start
	mappingOrganizations := map[string]*model.GroupUser{}
	products := map[*cpe.Item][]string{}
	domains := make([]string, 0)
	group, ctx := errgroup.WithContext(worker.context)
	// ===============================================================================
	// Thread 1: Find organizations
	group.Go(func() error {
		delay := clock.Minute * 5
		for {
			mappingRoles := make(map[string]*model.Role)
			tempMappingOrganizations := map[string]*model.GroupUser{}
			allowRoles := make([]string, 0)
			roles, err := worker.mongo.Roles().FindAll(ctx, &bson.M{"permissions": defs.PermissionViewVul}, []string{})
			if err != nil {
				worker.logger.Errorf("worker.mongo.Roles.FindAll failed, reason: %v", err)
				clock.Sleep(delay)
				continue
			}
			for _, role := range roles {
				mappingRoles[role.RoleID] = role
				allowRoles = append(allowRoles, role.RoleID)
			}
			orgs, err := worker.mongo.GroupUser().FindAll(ctx, &bson.M{"role": bson.M{"$in": allowRoles}}, []string{})
			if err != nil {
				worker.logger.Errorf("worker.mongo.GroupUser.FindAll failed, reason: %v", err)
				clock.Sleep(delay)
				continue
			}
			for _, org := range orgs {
				if org.IsActive() {
					org.Mass = mappingRoles[org.Role].Mass
					tempMappingOrganizations[org.TenantID] = org
				}
			}
			worker.mutex.Lock()
			mappingOrganizations = tempMappingOrganizations
			worker.mutex.Unlock()
			worker.logger.Infof("total: %d organizations", len(tempMappingOrganizations))
			select {
			case <-ctx.Done():
				return nil
			default:
				clock.Sleep(delay)
			}
		}
	})
	// ===============================================================================
	// Thread 2: Find assets
	group.Go(func() error {
		for {
			worker.mutex.Lock()
			if len(mappingOrganizations) == 0 {
				worker.mutex.Unlock()
				clock.Sleep(clock.Second * 5)
				continue
			}
			worker.mutex.Unlock()
			break
		}
		worker.logger.Infof("start find assets thread")
		delay := clock.Minute * 15
		for {
			// Start
			orgs := make([]string, 0)
			worker.mutex.Lock()
			for org, _ := range mappingOrganizations {
				orgs = append(orgs, org)
			}
			worker.mutex.Unlock()
			// Search
			query := map[string]interface{}{
				"bool": map[string]interface{}{
					"filter": []interface{}{
						map[string]interface{}{
							"term": map[string]interface{}{
								"type": defs.AssetTypeProduct,
							},
						},
						map[string]interface{}{
							"term": map[string]interface{}{
								"status": defs.AssetStatusCodeApproved,
							},
						},
						map[string]interface{}{
							"term": map[string]interface{}{
								"active": true,
							},
						},
						map[string]interface{}{
							"term": map[string]interface{}{
								"visible": true,
							},
						},
						map[string]interface{}{
							"terms": map[string]interface{}{
								"organization": orgs,
							},
						},
					},
				},
			}
			assets, err := worker.elastic.Enduser().Asset().FindAll(ctx, query, []string{})
			if err != nil {
				worker.logger.Errorf("worker.elastic.Enduser.Asset.FindAll failed, reason: %v", err)
				if err.Error() != es.NotFoundError {
					return err
				}
				clock.Sleep(delay)
				continue
			}
			worker.logger.Infof("total: %d assets", len(assets))
			mappingProducts := make(map[string][]string)
			for _, asset := range assets {
				if affectOrgs, ok := mappingProducts[asset.Value]; ok {
					affectOrgs = append(affectOrgs, asset.Organization)
					mappingProducts[asset.Value] = affectOrgs
				} else {
					mappingProducts[asset.Value] = []string{asset.Organization}
				}
			}
			tempProducts := make(map[*cpe.Item][]string)
			for pro, affectOrgs := range mappingProducts {
				c, ex := cpe.NewItemFromFormattedString(pro)
				if ex != nil {
					worker.logger.Warningf("cpe.NewItemFromFormattedString (%s) failed, reason: %v", pro, ex)
					continue
				}
				tempProducts[c] = affectOrgs
			}
			worker.mutex.Lock()
			products = tempProducts
			worker.mutex.Unlock()
			select {
			case <-ctx.Done():
				return nil
			default:
				clock.Sleep(delay)
			}
		}
	})
	// ===============================================================================
	// Thread 3: Find domains
	group.Go(func() error {
		for {
			worker.mutex.Lock()
			if len(mappingOrganizations) == 0 {
				worker.mutex.Unlock()
				clock.Sleep(clock.Second * 5)
				continue
			}
			worker.mutex.Unlock()
			break
		}
		worker.logger.Infof("start find domains thread")
		delay := clock.Minute * 30
		for {
			// Start
			orgs := make([]string, 0)
			worker.mutex.Lock()
			for org := range mappingOrganizations {
				orgs = append(orgs, org)
			}
			worker.mutex.Unlock()
			// Search
			query := map[string]interface{}{
				"bool": map[string]interface{}{
					"filter": []interface{}{
						map[string]interface{}{
							"term": map[string]interface{}{
								"type": defs.AssetTypeProduct,
							},
						},
						map[string]interface{}{
							"term": map[string]interface{}{
								"status": defs.AssetStatusCodeApproved,
							},
						},
						map[string]interface{}{
							"term": map[string]interface{}{
								"active": true,
							},
						},
						map[string]interface{}{
							"term": map[string]interface{}{
								"visible": true,
							},
						},
						map[string]interface{}{
							"terms": map[string]interface{}{
								"organization": orgs,
							},
						},
					},
				},
			}
			temp := make([]string, 0)
			assets, err := worker.elastic.Enduser().Asset().AggregationCount(ctx, query, map[string]int{"attribute.product_vendor": 10000})
			if err != nil {
				worker.logger.Errorf("worker.elastic.Enduser.Asset.AggregationCount failed, reason: %v", err)
				if err.Error() != es.NotFoundError {
					worker.logger.Errorf("worker.elastic.Enduser.Asset.AggregationCount failed, reason: %v", err)
				}
				clock.Sleep(delay)
				continue
			}
			if len(assets) == 0 {
				worker.logger.Infof("worker.elastic.Enduser.Asset.AggregationCount return no data")
				clock.Sleep(delay)
				continue
			}
			buckets, ok := assets["attribute.product_vendor"]
			if !ok {
				worker.logger.Infof("worker.elastic.Enduser.Asset.AggregationCount return no data")
				clock.Sleep(delay)
				continue
			}
			worker.logger.Infof("total: %d vendors", len(buckets))
			errorCount := 0
			for _, it := range buckets {
				refs, err := worker.getCVEReferences(fmt.Sprintf("%v", it.Value), defs.DefaultRetry)
				if err != nil {
					if err.Error() != es.NotFoundError {
						worker.logger.Errorf("worker.getCVEReferences failed, reason: %v", err)
						errorCount++
						break
					}
				}
				temp = append(temp, refs...)
			}
			if errorCount > 0 {
				worker.logger.Info("getCVEReferences failed, error count > 0")
				clock.Sleep(delay)
				continue
			}
			for _, dm := range worker.config.App.ReferenceVendors {
				temp = append(temp, dm)
			}
			temp = arrayx.Unique(temp)
			worker.logger.Infof("reference domains: %v", temp)
			if len(temp) > 0 {
				worker.mutex.Lock()
				domains = temp
				worker.mutex.Unlock()
			}
			select {
			case <-ctx.Done():
				return nil
			default:
				clock.Sleep(delay)
			}
		}
	})
	// Wait for assets and domains
	for {
		worker.mutex.Lock()
		if len(products) > 0 && len(domains) > 0 {
			worker.mutex.Unlock()
			break
		}
		worker.mutex.Unlock()
		select {
		case <-ctx.Done():
			return
		default:
			clock.Sleep(clock.Second * 5)
		}
	}
	// ===============================================================================
	// Thread 4: consume
	for range worker.config.App.Core {
		grConsumer, grContext := errgroup.WithContext(ctx)
		grConsumer.Go(func() error {
			queue := rabbit.NewService(grContext, worker.config.Adapter.Rabbit.Crawler, nil)
			err := queue.Consume(defs.QueueCveAnalyzer, false, 1, func(data []byte) error {
				var cve model.CVE
				if err := json.Unmarshal(data, &cve); err != nil {
					return worker.HandleError(err, data)
				}
				worker.logger.Infof("process: %s", cve.Name)
				worker.mutex.Lock()
				match := make([]string, 0)
				now, _ := clock.Now(clock.Local)
				for _, m := range cve.Match {
					actual, err := cpe.NewItemFromFormattedString(m)
					if err != nil {
						worker.logger.Errorf("failed to parse cpe (%s), reason: %v", m, err)
						continue
					}
					for asset, orgs := range products {
						if cpe.CheckSubset(asset, actual, true) || cpe.CheckSuperset(asset, actual, true) {
							for _, org := range orgs {
								if !arrayx.Contain(match, org) {
									match = append(match, org)
								}
							}
						}
					}
				}
				cve.Customer = match
				cve.Affect = int64(len(match))
				switch cve.Status {
				case defs.StatusCodeNew:
					if cve.Affect == 0 {
						cve.Status = defs.StatusCodeUnknown
					}
				case defs.StatusCodeUnknown:
					if cve.Affect > 0 {
						cve.Status = defs.StatusCodeNew
					}
				}
				// Check Mass?
				isOnlyMass := true
				for _, org := range match {
					if gr, ok := mappingOrganizations[org]; ok {
						if !gr.Mass {
							isOnlyMass = false
							break
						}
					}
				}
				// All Orgs are Mass and Status is New => Auto Approve
				if isOnlyMass && cve.Affect > 0 && cve.Status == defs.StatusCodeNew {
					cve.Status = defs.AssetStatusCodeApproved
					cve.AnalysisTime = clock.UnixMilli(now)
					cve.Approved = clock.UnixMilli(now)

					delivered := map[string]any{}
					for _, org := range cve.Organizations {
						delivered[org.TenantId] = nil
					}

					cveCustomers := []*model.CveCustomer{}
					for _, tenant := range cve.Customer {
						if _, ok := delivered[tenant]; !ok {
							delivered[tenant] = nil
							cve.Organizations = append(cve.Organizations, model.CveOrganization{
								ApprovalTime: now.UnixMilli(),
								TenantId:     tenant,
							})
							customer := &model.CveCustomer{
								CveID:        cve.Name,
								TenantID:     tenant,
								ApprovalTime: cve.Approved,
								Modified:     time.Now().UnixMilli(),
							}
							customer.GenID()
							cveCustomers = append(cveCustomers, customer)
						}
					}
					if len(cveCustomers) > 0 {
						err := worker.elastic.Enrichment().CVECustomer().StoreMany(ctx, cveCustomers)
						if err != nil {
							log.Printf("[error] failed to insert cve-customers: %v", err)
						}
					}
				}
				// Match Products => Update Analysis Time
				//hasAnalysisTime := false
				hasConditionNVD := cve.Score.Global.Score == 0 || cve.Score.Global.Score >= 7
				hasConditionCNA := (cve.Score.CNA.Version == defs.VersionCvssV20 || cve.Score.CNA.Version == defs.VersionCvssV30 || cve.Score.CNA.Version == defs.VersionCvssV31 || cve.Score.CNA.Version == defs.VersionCvssV40) && cve.Score.CNA.Score >= 7
				// ===========================================================================================================================\
				// Condition 1: Check mapping products
				// + Affect > 0
				// + Has NVD Severity (Unknown, High, Critical) OR Has CNA Severity (High, Critical)
				if cve.AnalysisTime == 0 && cve.Affect > 0 && (hasConditionNVD || hasConditionCNA) {
					cve.AnalysisTime = clock.UnixMilli(now)
					//hasAnalysisTime = true
				}
				// ===========================================================================================================================\
				// Condition 2: Check mapping references if Status is Unknown
				if cve.Status == defs.StatusCodeUnknown && (hasConditionNVD || hasConditionCNA) {
					for _, ref := range cve.Searchable.EN.Reference {
						for _, domain := range domains {
							if strings.Contains(ref, domain) {
								cve.Status = defs.StatusCodeNew
								cve.Modified = clock.UnixMilli(now)
								if cve.AnalysisTime == 0 {
									cve.AnalysisTime = clock.UnixMilli(now)
									//hasAnalysisTime = true
								}
								worker.logger.Infof("cve: %s match reference domain: %s", cve.Name, domain)
								break
							}
						}
						if cve.Status == defs.StatusCodeNew {
							break
						}
					}
				}
				worker.mutex.Unlock()
				worker.logger.Infof("done: %s, match: %d organizations", cve.Name, cve.Affect)
				// Update
				meta := &model.CVELogstash{
					CVE: cve,
					Metadata: model.Metadata{
						ID:    cve.ID,
						Index: defs.IndexCVE,
						Type:  defs.TypeCve,
					},
				}
				metaBts, _ := json.Marshal(meta)
				if err := worker.queue.Publish("", defs.QueueLogstashCve, rabbit.Message{
					Body:        metaBts,
					ContentType: rabbit.MIMEApplicationJSON,
					Mode:        rabbit.Persistent,
					Priority:    0,
				}); err != nil {
					return worker.HandleError(err, data)
				}
				// Create Analysis time lifecycle
				//if hasAnalysisTime {
				//	if err := insertVtiLifeCycle(worker.elastic.Enrichment().CVELifecycle(), model.CVE_EVENT_ANALYSIS_TIME, cve.Name, cve.AnalysisTime); err != nil {
				//		worker.logger.Errorf("insertVtiLifeCycle CVE_EVENT_ANALYSIS_TIME error, reason: %v", err)
				//	} else {
				//		worker.logger.Infof("insertVtiLifeCycle %s success, event: %v", cve.Name, model.CVE_EVENT_ANALYSIS_TIME)
				//	}
				//}
				// Success
				return nil
			})
			// Success
			return err
		})
		// Wait
		if err := grConsumer.Wait(); err != nil {
			worker.logger.Errorf("grConsumer.Wait", err)
		}
	}
	// ===============================================================================
	// Wait
	if err := group.Wait(); err != nil {
		worker.logger.Errorf("group.Wait failed, reason: %v", err)
	}
}

func (worker *cveAnalyzer) HandleError(err error, bts []byte) error {
	worker.logger.Errorf("process CVE error, reason: %v", err)
	if err = worker.queue.Publish("", defs.QueueCveAnalyzerError, rabbit.Message{
		Body:        bts,
		ContentType: rabbit.MIMEApplicationJSON,
		Mode:        rabbit.Persistent,
		Priority:    0,
	}); err != nil {
		return err
	}
	// Success
	return nil
}

func (worker *cveAnalyzer) Prepare() {
	if err := worker.queue.DeclareQueue(defs.QueueLogstashCve, true, 0, 0); err != nil {
		panic(err)
	}
	if err := worker.queue.DeclareQueue(defs.QueueCveParser, true, 0, 0); err != nil {
		panic(err)
	}
	if err := worker.queue.DeclareQueue(defs.QueueCveAnalyzer, true, 0, 0); err != nil {
		panic(err)
	}
	if err := worker.queue.DeclareQueue(defs.QueueCveAnalyzerError, true, 0, 0); err != nil {
		panic(err)
	}
}

func (worker *cveAnalyzer) getCVEReferences(vendor string, retry int) ([]string, error) {
	queryCve := map[string]interface{}{
		"nested": map[string]interface{}{
			"path": "cve.references.reference_data",
			"query": map[string]interface{}{
				"bool": map[string]interface{}{
					"filter": []interface{}{
						map[string]interface{}{
							"wildcard": map[string]interface{}{
								"cve.references.reference_data.url": fmt.Sprintf("*%s*", vendor),
							},
						},
					},
				},
			},
		},
	}
	resCVE, err := worker.elastic.Enrichment().CVERaw().FindAll(worker.context, queryCve, []string{})
	if err != nil {
		if err.Error() != es.NotFoundError {
			worker.logger.Errorf("worker.elastic.Enrichment.CVERaw.FindAll failed, reason: %v", err)
			if retry > 0 {
				worker.logger.Debugf("worker.elastic.Enrichment.CVERaw.FindAll failed, reason: %v, retry: %d", err, retry)
				return worker.getCVEReferences(vendor, retry-1)
			}
		}
		return nil, err
	}
	results := make([]string, 0)
	for _, item := range resCVE {
		refs := item.GetReferenceURL()
		for _, ref := range refs {
			tldResult := worker.tld.Extract(ref)
			domain := tldResult.RootDomain()
			if domain == "" {
				continue
			}
			if strings.Contains(domain, vendor) {
				results = append(results, domain)
			}
		}
	}
	// Success
	return arrayx.Unique(results), nil
}
