package processor

import (
	"context"
	"crypto/tls"
	"cve-crawler/adapter/elastic"
	"cve-crawler/defs"
	"cve-crawler/model"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"sync"
	"time"

	es "gitlab.viettelcyber.com/awesome-threat/library/adapter/elastic"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/redis"
	"gitlab.viettelcyber.com/awesome-threat/library/hash"

	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"golang.org/x/sync/errgroup"
	"golang.org/x/time/rate"

	"github.com/go-resty/resty/v2"
	"github.com/robfig/cron/v3"
)

type CveEpssJob struct {
	Name        string
	Context     context.Context
	Logger      pencil.Logger
	Elastic     elastic.EnrichmentRepository
	Config      model.WorkerConfig
	Client      *resty.Client
	Mutex       *sync.Mutex
	Cron        *cron.Cron
	RateLimiter *rate.Limiter
	Cache       redis.Service
	JobsChan    chan []*model.FirstOrgCveEpssData
}

type CveEpssCache struct {
	ID    string   `json:"id"`
	Score *float64 `json:"score"`
}

func NewCveEpssJob(ctx context.Context, conf model.WorkerConfig) Processor {
	logger, _ := pencil.New(defs.WorkerCveEpss, pencil.DebugLevel, true, os.Stdout)
	worker := CveEpssJob{
		Name:        defs.WorkerCveEpss,
		Context:     ctx,
		Logger:      logger,
		Config:      conf,
		Mutex:       &sync.Mutex{},
		RateLimiter: rate.NewLimiter(16, 4),
		Cache:       redis.NewService(conf.Adapter.Redis.General, nil),
		JobsChan:    make(chan []*model.FirstOrgCveEpssData, 20),
	}
	worker.Elastic = elastic.NewEnrichmentRepository(worker.Config.Adapter.Elastic.Enrichment)
	client := resty.New()
	client.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})
	client.SetTimeout(time.Duration(clock.Minute * clock.Duration(worker.Config.App.Timeout)))
	if worker.Config.App.Proxy.Enable {
		client.SetProxy(worker.Config.App.Proxy.String())
	}
	worker.Client = client
	// Success
	return &worker
}

func (worker *CveEpssJob) Start() {
	// Start
	cronSpec := worker.Config.Jobs.EpssJob.CronSpec
	if cronSpec == "" {
		cronSpec = "0 0 0 * * *"
	}
	c := cron.New(cron.WithSeconds())
	_, err := c.AddFunc(cronSpec, func() {
		worker.Logger.Infof("[Cron] Starting EPSS job at %s\n", time.Now().Format(time.RFC3339))
		if err := worker.RunJob(); err != nil {
			worker.Logger.Errorf("[Cron] Failed to run EPSS job: %v", err)
		}
	})
	if err != nil {
		panic(err)
	}
	c.Start()
	worker.Logger.Infof("[Cron] EPSS job scheduled with cron: %s", cronSpec)
	<- worker.Context.Done()
}

func (j *CveEpssJob) RunJob() error {
	numWorkers := 10
	g, ctx := errgroup.WithContext(j.Context)
	// Tạo worker xử lý jobs
	for i := 0; i < numWorkers; i++ {
		workerID := i
		g.Go(func() error {
			return j.ProcessEpssBatchWorker(ctx, workerID, j.JobsChan)
		})
	}
	// Goroutine fetch dữ liệu đẩy vào channel
	g.Go(func() error {
		//defer close(j.JobsChan)
		return j.ProcessEpssDataFetchBatch(ctx, j.JobsChan)
	})
	// Chờ tất cả goroutine kết thúc
	if err := g.Wait(); err != nil {
		j.Logger.Errorf("failed process sync epss data: %v", err)
		return err
	}
	return nil
}

func (j *CveEpssJob) ProcessEpssBatchWorker(ctx context.Context, workerID int, jobs <-chan []*model.FirstOrgCveEpssData) error {
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case batch, ok := <-jobs:
			if !ok {
				return nil // Channel đã đóng
			}
			if err := j.ProcessEpssBatch(ctx, batch); err != nil {
				j.Logger.Errorf("failed process batch for worker %d: %v", workerID, err)
			}
		}
	}
}

func (j *CveEpssJob) ProcessEpssDataFetchBatch(ctx context.Context, jobs chan<- []*model.FirstOrgCveEpssData) error {
	page := 1
	for {
		epssDataList := j.FetchEpssData(ctx, page)
		if len(epssDataList) == 0 {
			break
		}
		// Chia batch 5000
		for i := 0; i < len(epssDataList); i += 5000 {
			end := i + 5000
			if end > len(epssDataList) {
				end = len(epssDataList)
			}
			batch := epssDataList[i:end]
			select {
			case <-ctx.Done():
				return ctx.Err()
			case jobs <- batch:
				j.Logger.Info("Pushed batch to channel")
			}
		}
		page++
	}
	return nil
}

func (j *CveEpssJob) FetchEpssData(ctx context.Context, page int) []*model.FirstOrgCveEpssData {
	if err := j.RateLimiter.Wait(ctx); err != nil {
		j.Logger.Errorf("rate limiter wait error: %v", err)
		return nil
	}
	limit := 10000
	offset := (page - 1) * limit
	pageURL := fmt.Sprintf("%s?limit=%d&offset=%d", j.Config.FirstCveEpssAPI, limit, offset)
	j.Logger.Infof("[Info]: %s", pageURL)
	resp, err := j.Client.R().
		SetContext(ctx).
		Get(pageURL)

	if err != nil {
		j.Logger.Errorf("API call failed for page %d: %v", page, err)
		return nil
	}

	if resp.StatusCode() != 200 {
		j.Logger.Errorf("API returned status %d for page %d", resp.StatusCode(), page)
		return nil
	}

	var pageData model.FirstOrgCveEpssResponse
	if err := json.Unmarshal(resp.Body(), &pageData); err != nil {
		j.Logger.Errorf("JSON parse failed for page %d: %v", page, err)
		return nil
	}
	return pageData.Data
}

func (j *CveEpssJob) ProcessEpssBatch(ctx context.Context, batch []*model.FirstOrgCveEpssData) error {
	var needUpdateItems []*model.FirstOrgCveEpssData
	var cacheDataMap = make(map[string]*CveEpssCache)
	// 1. Check cache và tìm item cần update
	for _, item := range batch {
		newScore, err := strconv.ParseFloat(item.Epss, 64)
		if err != nil {
			j.Logger.Errorf("invalid EPSS score format %s for %s", item.Epss, item.Cve)
			continue
		}
		cveHashID := hash.SHA1(item.Cve)
		cachedData, err := j.getCveScoreFromCache(ctx, item.Cve)
		j.Logger.Infof("Raw cache: %+v", cachedData)
		if err != nil {
			j.Logger.Errorf("cache get error for %s: %v", item.Cve, err)
			continue
		}
		if cachedData == nil {
			existingCVE, err := j.Elastic.CVE().GetByName(ctx, item.Cve)
			if err != nil {
				j.Logger.Errorf("ES query failed for %s: %v", item.Cve, err)
				continue
			}
			if existingCVE == nil {
				continue
			}
			cachedData = &CveEpssCache{
				ID:    cveHashID,
				Score: existingCVE.Epss.Score,
			}
			if err := j.setCveScoreToCache(ctx, item.Cve, cachedData.Score, cachedData.ID); err != nil {
				j.Logger.Errorf("cache set error for %s: %v", item.Cve, err)
			}
			j.Logger.Infof("Successfully set cache", "cve", item.Cve, "score", cachedData.Score, "id", cachedData.ID)
		}
		if cachedData.Score == nil || *cachedData.Score != newScore {
			if item.Cve != "" {
				needUpdateItems = append(needUpdateItems, item)
				cacheDataMap[item.Cve] = cachedData
			}
		}
	}

	// 2. Nếu không có gì cần update thì return
	if len(needUpdateItems) == 0 {
		j.Logger.Infof("No items need update in this batch")
		return nil
	}

	// 3. Chuẩn bị bulk update và history
	var bulkCVEUpdates []es.UpdateDocument
	var bulkHistories []*model.CveEpssHistory
	for _, item := range needUpdateItems {
		cachedData := cacheDataMap[item.Cve]
		newScore, _ := strconv.ParseFloat(item.Epss, 64)
		newPercentile, _ := strconv.ParseFloat(item.Percentile, 64)
		bulkCVEUpdates = append(bulkCVEUpdates, es.UpdateDocument{
			ID: cachedData.ID,
			Update: map[string]any{
				"epss": map[string]any{
					"score":      &newScore,
					"percentile": &newPercentile,
				},
			},
		})

		now, _ := clock.Now(clock.Local)
		history := &model.CveEpssHistory{
			CveName:  item.Cve,
			Date:     uint64(clock.UnixMilli(now)),
			Editor:   defs.EditorUserName,
			OldScore: cachedData.Score,
			NewScore: &newScore,
		}
		history.GenID()
		bulkHistories = append(bulkHistories, history)
	}

	// 4. Thực hiện bulk update
	if len(bulkCVEUpdates) > 0 {
		if err := j.Elastic.CVE().UpdateMany(ctx, bulkCVEUpdates); err != nil {
			j.Logger.Errorf("bulk update CVE failed: %v", err)
			return err
		}
		if err := j.Elastic.CVEEpssHistory().StoreAll(ctx, bulkHistories); err != nil {
			j.Logger.Errorf("bulk store history failed: %v", err)
			return err
		}
		// 5. Update cache sau khi update thành công
		for _, item := range needUpdateItems {
			if item.Epss == "" || item.Cve == "" {
				continue
			}
			newScore, err := strconv.ParseFloat(item.Epss, 64)
			if err != nil {
				continue
			}
			cachedData, exists := cacheDataMap[item.Cve]
			if !exists || cachedData.ID == "" {
				continue
			}
			if err := j.setCveScoreToCache(ctx, item.Cve, &newScore, cachedData.ID); err != nil {
				j.Logger.Errorf("cache set error for %s: %v", item.Cve, err)
			}
		}
		j.Logger.Infof("Successfully bulk updated %d CVEs", len(bulkCVEUpdates))
	}
	return nil
}

func (j *CveEpssJob) setCveScoreToCache(ctx context.Context, cveName string, score *float64, cveID string) error {
	cacheData := CveEpssCache{
		ID:    cveID,
		Score: score,
	}
	jsonData, err := json.Marshal(cacheData)
	j.Logger.Infof("Raw cache value: %s", jsonData)
	if err != nil {
		return err
	}
	// Key: "epss-{CVE_NAME}"
	return j.Cache.Strings().Set("epss-"+cveName, string(jsonData), 0)
}

func (j *CveEpssJob) getCveScoreFromCache(ctx context.Context, cveName string) (*CveEpssCache, error) {
	cacheKey := "epss-" + cveName
	j.Logger.Infof("cache key: %s", cacheKey)
	cacheValue, err := j.Cache.Strings().Get(cacheKey)
	if err != nil {
		return nil, err
	}
	if cacheValue == "" {
		return nil, nil
	}
	var cacheData CveEpssCache
	if err := json.Unmarshal([]byte(cacheValue), &cacheData); err != nil {
		return nil, err
	}
	return &cacheData, nil
}
