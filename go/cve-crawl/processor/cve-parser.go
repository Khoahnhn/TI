package processor

import (
	"context"
	"encoding/json"
	"fmt"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/kafka"
	"os"
	"runtime"
	"strconv"
	"strings"

	"cve-crawler/adapter/elastic"
	"cve-crawler/defs"
	"cve-crawler/model"

	es "gitlab.viettelcyber.com/awesome-threat/library/adapter/elastic"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"gitlab.viettelcyber.com/awesome-threat/library/slice"
	vulmodel "gitlab.viettelcyber.com/awesome-threat/vulpriority-component/model"
	"golang.org/x/sync/errgroup"
)

type cveParser struct {
	name            string
	context         context.Context
	logger          pencil.Logger
	elastic         elastic.EnrichmentRepository
	queue           rabbit.Service
	config          model.WorkerConfig
	chanEventJobVul chan *vulmodel.Event
}

func newCveParser(ctx context.Context, conf model.WorkerConfig) Processor {
	logger, _ := pencil.New(defs.WorkerCveParser, pencil.DebugLevel, true, os.Stdout)
	worker := cveParser{name: defs.WorkerCveParser, context: ctx, logger: logger, config: conf}
	// Repository
	worker.elastic = elastic.NewEnrichmentRepository(worker.config.Adapter.Elastic.Enrichment)
	worker.queue = rabbit.NewService(worker.context, worker.config.Adapter.Rabbit.Crawler, nil)
	worker.chanEventJobVul = make(chan *vulmodel.Event, 100)
	// Success
	return &worker
}

func (worker *cveParser) Start() {
	// Prepare
	worker.Prepare()
	// Start
	if worker.config.App.Core == 0 {
		worker.config.App.Core = runtime.NumCPU()
	}
	worker.logger.Debugf("Core: %d", worker.config.App.Core)

	group, ctx := errgroup.WithContext(worker.context)
	// Consume
	for i := 0; i < worker.config.App.Core; i++ {
		queue := rabbit.NewService(ctx, worker.config.Adapter.Rabbit.Crawler, nil)
		group.Go(func() error {
			err := queue.Consume(defs.QueueCveParser, false, 1, func(data []byte) error {
				var raw model.CVERaw
				if err := json.Unmarshal(data, &raw); err != nil {
					return worker.HandleError(err, data)
				}
				worker.logger.Infof("process: %s", raw.Detail.Metadata.ID)
				// send-vul-priority-crawler-chanel
				worker.chanEventJobVul <- &vulmodel.Event{
					Name: raw.Detail.Metadata.ID,
				}
				// send cve-lifecycle-queue
				if err := queue.Publish("", defs.QueueCveLifecycle, rabbit.Message{
					Body:        []byte(raw.Detail.Metadata.ID),
					ContentType: rabbit.MIMETextPlain,
					Mode:        rabbit.Persistent,
					Priority:    5,
				}); err != nil {
					worker.logger.Errorf("send queue %s from code %s error, reason: %v", defs.QueueCveLifecycle, raw.Detail.Metadata.ID, err)
				} else {
					worker.logger.Infof("send queue %s from code %s success", defs.QueueCveLifecycle, raw.Detail.Metadata.ID)
				}
				modified := clock.UnixMilli(raw.GetLastModified())
				lang := &model.CVELang{
					ID:        raw.GetID(),
					Reference: []string{},
					Patch:     []string{},
					Lang:      defs.LangEn,
				}
				langVi := &model.CVELang{
					ID:        raw.GetID(),
					Reference: []string{},
					Patch:     []string{},
					Lang:      defs.LangVi,
				}
				nvdMetric := raw.GetLatestCVSS(defs.SourceNVD)
				saved, err := worker.elastic.CVE().GetByID(ctx, raw.GetID())
				if err != nil {
					if err.Error() != es.NotFoundError {
						worker.logger.Infof("[parser] cve: %s error, reason: %s", raw.Detail.Metadata.ID, err)
						// Republish ERROR CVE
						if ex := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
							Body:        data,
							ContentType: rabbit.MIMEApplicationJSON,
							Mode:        rabbit.Persistent,
							Priority:    0,
						}); ex != nil {
							worker.logger.Errorf("republish %s to %s failed, reason: %v", raw.Detail.Metadata.ID, defs.QueueCveParser, ex)
						}
						worker.logger.Infof("republish %s to %s success", raw.Detail.Metadata.ID, defs.QueueCveParser)
						return worker.HandleError(err, data)
					}
					worker.logger.Infof(fmt.Sprintf("[parser] first time cve: %s", raw.Detail.Metadata.ID))
					now, _ := clock.Now(clock.Local)
					nowUnix := clock.UnixMilli(now)
					saved = &model.CVE{
						Status:   defs.StatusCodeUnknown,
						Created:  nowUnix,
						Modified: modified,
						Crawled:  nowUnix,
						Checklist: model.CVEChecklist{
							Metric: model.CVECheckListMetric{
								Affect:    defs.PointNil,
								Exploit:   defs.PointNil,
								Patch:     defs.PointNil,
								Ability:   defs.PointNil,
								Condition: defs.PointNil,
							},
							Point: 0,
						},
						Match:      raw.GetProducts(),
						Approved:   modified,
						CPEDetails: raw.GetDetailProducts(),
						CPENodes:   raw.Configurations.Nodes,
						Source:     "NVD",
						Creator:    "VTI system",
					}

					// Language
					if lang.Raw == "" {
						description := strings.Join(raw.GetDescriptions(), "\n")
						lang.Raw = description
						lang.Description = description
						saved.Searchable.EN.Description = description
						saved.Searchable.EN.Reference = raw.GetReference()
					}
					lang.Reference = raw.GetReference()
					lang.Patch = raw.GetPatch()
				} else {
					if modified <= saved.Latest {
						return nil
					}
					currentCVE := *saved
					saved.Match = raw.GetProducts()
					saved.CPEDetails = raw.GetDetailProducts()
					saved.CPENodes = raw.Configurations.Nodes
					// Parse Lang EN
					lang, err = worker.elastic.CVELanguage(defs.LangEn).GetByID(ctx, saved.ID)
					if err != nil {
						if err.Error() != es.NotFoundError {
							worker.logger.Infof("[parser] cve: %s error, reason: %s", raw.Detail.Metadata.ID, err)
							// Republish
							if ex := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
								Body:        data,
								ContentType: rabbit.MIMEApplicationJSON,
								Mode:        rabbit.Persistent,
								Priority:    0,
							}); ex != nil {
								worker.logger.Errorf("republish %s to %s failed, reason: %v", raw.Detail.Metadata.ID, defs.QueueCveParser, ex)
							}
							worker.logger.Infof("republish %s to %s success", raw.Detail.Metadata.ID, defs.QueueCveParser)
							return worker.HandleError(err, data)
						}
						lang = &model.CVELang{
							ID:        saved.ID,
							Reference: []string{},
							Patch:     []string{},
							Lang:      defs.LangEn,
						}
					}
					// Parse Lang VI
					langVi, err = worker.elastic.CVELanguage(defs.LangVi).GetByID(ctx, saved.ID)
					if err != nil {
						if err.Error() != es.NotFoundError {
							// Republish
							if ex := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
								Body:        data,
								ContentType: rabbit.MIMEApplicationJSON,
								Mode:        rabbit.Persistent,
								Priority:    0,
							}); ex != nil {
								worker.logger.Errorf("republish %s to %s failed, reason: %v", raw.Detail.Metadata.ID, defs.QueueCveParser, ex)
							}
							worker.logger.Infof("republish %s to %s success", raw.Detail.Metadata.ID, defs.QueueCveParser)
							return worker.HandleError(err, data)
						}
						langVi = &model.CVELang{
							ID:        saved.ID,
							Reference: []string{},
							Patch:     []string{},
							Lang:      defs.LangVi,
						}
					}

					history, err := worker.elastic.CVEHistory().GetCVEHistoryByCVEIdAndAction(ctx, saved.ID)
					if err != nil && err.Error() != es.NotFoundError {
						worker.logger.Infof("[parser] cve: %s error, reason: %s", raw.Detail.Metadata.ID, err)
						// Republish
						if ex := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
							Body:        data,
							ContentType: rabbit.MIMEApplicationJSON,
							Mode:        rabbit.Persistent,
							Priority:    0,
						}); ex != nil {
							worker.logger.Errorf("republish %s to %s failed, reason: %v", raw.Detail.Metadata.ID, defs.QueueCveParser, ex)
						}
						worker.logger.Infof("republish %s to %s success", raw.Detail.Metadata.ID, defs.QueueCveParser)
						return worker.HandleError(err, data)
					}

					if saved.Status == defs.StatusCodeReject || (len(history) != 0 && (saved.Status == defs.StatusCodeNew || saved.Status == defs.StatusCodeApproved || saved.Status == defs.StatusCodeUnknown)) {
						for _, it := range currentCVE.Match {
							if !slice.String(saved.Match).Contains(it) {
								saved.Match = append(saved.Match, it)
							}
						}
						if saved.Status != defs.StatusCodeReject {
							now, _ := clock.Now(clock.Local)
							saved.Modified = clock.UnixMilli(now)
						}
					} else {
						// Language
						description := strings.Join(raw.GetDescriptions(), "\n")
						lang.Raw = description
						lang.Description = description
						saved.Searchable.EN.Description = description
						saved.Searchable.EN.Reference = raw.GetReference()
						lang.Reference = raw.GetReference()
						lang.Patch = raw.GetPatch()

						if saved.Status == defs.StatusCodeNew {
							if currentCVE.Score.Global.Severity != nvdMetric.Severity && (nvdMetric.Severity == defs.SeverityCodeHigh || nvdMetric.Severity == defs.SeverityCodeCritical) {
								now, _ := clock.Now(clock.Local)
								saved.Modified = clock.UnixMilli(now)
							} else {
								langVi.Reference = raw.GetReference()
								langVi.Patch = raw.GetPatch()
							}
						}

						if saved.Status == defs.StatusCodeUnknown {
							now, _ := clock.Now(clock.Local)
							saved.Modified = clock.UnixMilli(now)
							langVi.Reference = raw.GetReference()
							langVi.Patch = raw.GetPatch()
						}
					}
				}
				// Create
				saved.ID = raw.GetID()
				saved.Name = raw.Detail.Metadata.ID
				saved.Latest = clock.UnixMilli(raw.GetLastModified())
				saved.Published = clock.UnixMilli(raw.GetPublished())
				if saved.Checker == "" {
					saved.Checker = defs.DefaultChecker
				}

				saved.IsRecheck = false
				if nvdMetric.Severity == defs.SeverityCodeUnknown {
					saved.IsRecheck = true
				}
				// Score NVD
				saved.Score.Global.Severity = nvdMetric.Severity
				saved.Score.Global.Version = nvdMetric.Version
				saved.Score.Global.Score = nvdMetric.Score
				if ok, metric40 := raw.GetCVSSV4(defs.SourceNVD); ok {
					saved.Score.CVSS4 = *metric40
				}
				if ok, metric31 := raw.GetCVSSV3(defs.SourceNVD); ok {
					saved.Score.CVSS3 = *metric31
				}
				if ok, metric20 := raw.GetCVSSV2(defs.SourceNVD); ok {
					saved.Score.CVSS2 = *metric20
				}
				// Score CNA
				cnaMetric := raw.GetLatestCVSS(defs.SourceCNA)
				if cnaMetric.Severity != defs.SeverityCodeUnknown {
					saved.Score.CNA = *cnaMetric
				}
				// Score VTI
				saved.Score.VTI.Version = defs.VersionVcs10

				saved.Vendor = raw.GetVendor(saved.Match)
				if len(saved.Vendor) == 0 {
					saved.Vendor = []string{defs.TitleVendorUnknown}
				}
				if len(saved.Customer) == 0 {
					saved.Customer = []string{}
				}

				if len(saved.Languages) == 0 {
					saved.Languages = []string{defs.LangEn}
				}
				// Cwe
				cweAdded := map[string]bool{}
				for _, cwe := range saved.Cwe {
					cweAdded[cwe.ID] = true
				}
				for _, data := range raw.Detail.ProblemType.Data {
					for _, desc := range data.Description {
						value := strings.ToLower(desc.Value)
						if !strings.HasPrefix(value, "cwe") {
							continue
						}
						cweCodeStr := strings.TrimPrefix(value, "cwe-")
						cweCode, err := strconv.ParseInt(cweCodeStr, 10, 64)
						if err != nil {
							worker.logger.Infof("Failed to parse cwe code for string: %v\n", desc.Value)
							// .Printf("Failed to parse cwe code for string: %v\n", desc.Value)
							continue
						}
						if cweAdded[desc.Value] {
							continue
						}
						cweAdded[desc.Value] = true
						cwe, err := worker.elastic.CWE().GetByCWEId(ctx, desc.Value)
						if err != nil {
							worker.logger.Infof("[Worker] Elastic CWE error: %w", err)
						}
						cweName := ""
						if cwe != nil {
							cweName = cwe.Name
						}
						saved.Cwe = append(saved.Cwe, model.CWEMetric{
							ID:   desc.Value,
							Name: cweName,
							Link: fmt.Sprintf(defs.CWE_INFO_SITE, cweCode),
						})
					}
				}
				// // Send document to logstash-cve-queue
				// meta := &model.CVELogstash{
				// 	CVE: *saved,
				// 	Metadata: model.Metadata{
				// 		ID:    saved.ID,
				// 		Index: defs.IndexCVE,
				// 		Type:  defs.TypeCve,
				// 	},
				// }
				// metaBts, _ := json.Marshal(meta)
				// if err := queue.Publish("", defs.QueueLogstashCve, rabbit.Message{
				// 	Body:        metaBts,
				// 	ContentType: rabbit.MIMEApplicationJSON,
				// 	Mode:        rabbit.Persistent,
				// 	Priority:    0,
				// }); err != nil {
				// 	// Republish
				// 	if ex := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
				// 		Body:        data,
				// 		ContentType: rabbit.MIMEApplicationJSON,
				// 		Mode:        rabbit.Persistent,
				// 		Priority:    0,
				// 	}); ex != nil {
				// 		worker.logger.Errorf("republish %s to %s failed, reason: %v", raw.Detail.Metadata.ID, defs.QueueCveParser, ex)
				// 	}
				// 	worker.logger.Infof("republish %s to %s success", raw.Detail.Metadata.ID, defs.QueueCveParser)
				// 	return worker.HandleError(err, data)
				// }
				// Send language EN to logstash-cve-queue
				metaLang := &model.CVELangLogstash{
					CVELang: *lang,
					Metadata: model.Metadata{
						ID:    lang.ID,
						Index: fmt.Sprintf(defs.IndexCVELang, defs.LangEn),
						Type:  defs.TypeCve,
					},
				}
				metaLangBts, _ := json.Marshal(metaLang)
				if err := queue.Publish("", defs.QueueLogstashCve, rabbit.Message{
					Body:        metaLangBts,
					ContentType: rabbit.MIMEApplicationJSON,
					Mode:        rabbit.Persistent,
					Priority:    0,
				}); err != nil {
					// Republish
					if ex := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
						Body:        data,
						ContentType: rabbit.MIMEApplicationJSON,
						Mode:        rabbit.Persistent,
						Priority:    0,
					}); ex != nil {
						worker.logger.Errorf("republish %s to %s failed, reason: %v", raw.Detail.Metadata.ID, defs.QueueCveParser, ex)
					}
					worker.logger.Infof("republish %s to %s success", raw.Detail.Metadata.ID, defs.QueueCveParser)
					return worker.HandleError(err, data)
				}
				// Send language VI to logstash-cve-queue if new
				if saved.Status == defs.StatusCodeNew || saved.Status == defs.StatusCodeUnknown {
					metaLangVi := &model.CVELangLogstash{
						CVELang: *langVi,
						Metadata: model.Metadata{
							ID:    lang.ID,
							Index: fmt.Sprintf(defs.IndexCVELang, defs.LangVi),
							Type:  defs.TypeCve,
						},
					}
					metaLangViBts, _ := json.Marshal(metaLangVi)
					if err := queue.Publish("", defs.QueueLogstashCve, rabbit.Message{
						Body:        metaLangViBts,
						ContentType: rabbit.MIMEApplicationJSON,
						Mode:        rabbit.Persistent,
						Priority:    0,
					}); err != nil {
						// Republish
						if ex := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
							Body:        data,
							ContentType: rabbit.MIMEApplicationJSON,
							Mode:        rabbit.Persistent,
							Priority:    0,
						}); ex != nil {
							worker.logger.Errorf("republish %s to %s failed, reason: %v", raw.Detail.Metadata.ID, defs.QueueCveParser, ex)
						}
						worker.logger.Infof("republish %s to %s success", raw.Detail.Metadata.ID, defs.QueueCveParser)
						return worker.HandleError(err, data)
					}
					// Create CVE lifecycle
					// if saved.Status == defs.StatusCodeUnknown {
					// 	if err := insertVtiLifeCycle(worker.elastic.CVELifecycle(), model.CVE_EVENT_CREATE_CVE, saved.Name, saved.Created); err != nil {
					// 		worker.logger.Errorf("insertVtiLifeCycle CVE_EVENT_CREATE_CVE error, reason: %v", err)
					// 	} else {
					// 		worker.logger.Infof("insertVtiLifeCycle %s success, event: %v", saved.Name, model.CVE_EVENT_CREATE_CVE)
					// 	}
					// }
				}

				// Send cve-analyzer-queue
				dataBts, _ := json.Marshal(saved)
				if err := queue.Publish("", defs.QueueCveAnalyzer, rabbit.Message{
					Body:        dataBts,
					ContentType: rabbit.MIMEApplicationJSON,
					Mode:        rabbit.Persistent,
					Priority:    0,
				}); err != nil {
					// Republish
					if ex := worker.queue.Publish("", defs.QueueCveParser, rabbit.Message{
						Body:        data,
						ContentType: rabbit.MIMEApplicationJSON,
						Mode:        rabbit.Persistent,
						Priority:    0,
					}); ex != nil {
						worker.logger.Errorf("republish %s to %s failed, reason: %v", raw.Detail.Metadata.ID, defs.QueueCveParser, ex)
					}
					worker.logger.Infof("republish %s to %s success", raw.Detail.Metadata.ID, defs.QueueCveParser)
					return worker.HandleError(err, data)
				}
				worker.logger.Infof("complete: %s, products: %d, cpes: %d", saved.Name, len(saved.Match), len(saved.CPEDetails))
				// Success
				return nil
			})
			// Success
			return err
		})
	}

	//Publish job crawler vul priority
	group.Go(func() error {
		if err := worker.ProcPublishJobCrawVulPriority(ctx); err != nil {
			return err
		}
		// Success
		return nil
	})
}

func (worker *cveParser) HandleError(err error, bts []byte) error {
	worker.logger.Errorf("process CVE error, reason: %v", err)
	if err = worker.queue.Publish("", defs.QueueCveParserError, rabbit.Message{
		Body:        bts,
		ContentType: rabbit.MIMEApplicationJSON,
		Mode:        rabbit.Persistent,
		Priority:    0,
	}); err != nil {
		return err
	}
	// Success
	return nil
}

func (worker *cveParser) Prepare() {
	if err := worker.queue.DeclareQueue(defs.QueueLogstashCve, true, 0, 0); err != nil {
		panic(err)
	}
	if err := worker.queue.DeclareQueue(defs.QueueCveParser, true, 0, 0); err != nil {
		panic(err)
	}
	if err := worker.queue.DeclareQueue(defs.QueueCveParserError, true, 0, 0); err != nil {
		panic(err)
	}
	if err := worker.queue.DeclareQueue(defs.QueueCveAnalyzer, true, 0, 0); err != nil {
		panic(err)
	}
	if err := worker.queue.DeclareQueue(defs.QueueCveLifecycle, true, 0, 0); err != nil {
		panic(err)
	}
}

func (worker *cveParser) ProcPublishJobCrawVulPriority(ctx context.Context) error {
	producer, err := kafka.NewProducer(ctx, worker.config.Adapter.Kafka.Producer)
	if err != nil {
		worker.logger.Errorf("kafka.NewProducer failed, reason: %v", err)
		return err
	}
	for event := range worker.chanEventJobVul {
		bts, err := json.Marshal(event)
		if err != nil {
			worker.logger.Errorf("json.Marshal failed, reason: %v", err)
			continue
		}
		if err = producer.Produce(worker.config.Adapter.Kafka.Topic.VulPriorityJobCollectTopic, "", bts); err != nil {
			worker.logger.Errorf("producer.Produce failed, reason: %v", err)
			continue
		}
		worker.logger.Infof("Push success %v to crawler topic ", event.Name)
	}
	// Success
	return nil
}
