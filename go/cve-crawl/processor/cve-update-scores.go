package processor

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"time"

	"github.com/go-resty/resty/v2"
	"golang.org/x/sync/errgroup"
	"golang.org/x/time/rate"

	es "gitlab.viettelcyber.com/awesome-threat/library/adapter/elastic"
	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"gitlab.viettelcyber.com/awesome-threat/library/rest"

	"cve-crawler/adapter/elastic"
	"cve-crawler/defs"
	"cve-crawler/model"
)

type cveUpdateScores struct {
	name    string
	context context.Context
	logger  pencil.Logger
	elastic elastic.EnrichmentRepository
	config  model.WorkerConfig
	client  *resty.Client
	limiter *rate.Limiter
}

func newCVEUpdateScores(ctx context.Context, conf model.WorkerConfig) Processor {
	logger, _ := pencil.New(defs.WorkerCveCrawlerAPI, pencil.DebugLevel, true, os.Stdout)
	worker := cveUpdateScores{name: defs.WorkerCveCrawlerAPI, context: ctx, logger: logger, config: conf}
	// Repository
	// Client
	client := resty.New()
	client.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})
	client.SetTimeout(time.Duration(clock.Minute * clock.Duration(worker.config.App.Timeout)))
	if worker.config.App.Proxy.Enable {
		client.SetProxy(worker.config.App.Proxy.String())
	}
	rateLimit := 10
	worker.limiter = rate.NewLimiter(rate.Every(time.Second*time.Duration(rateLimit)), 1)
	worker.client = client
	worker.elastic = elastic.NewEnrichmentRepository(worker.config.Adapter.Elastic.Enrichment)
	// Success
	return &worker
}

func (worker *cveUpdateScores) Start() {
	group, ctx := errgroup.WithContext(worker.context)
	worker.logger.Debug("Start the worker to update CVE's scores")
	worker.logger.Debugf("Test mode: %v", worker.config.TestMode.Enable)
	updateAll := false
	getFirstCVEOnly := false
	updateFirstCVEOnly := false
	getFirstCVEPageOnly := false
	updateFirstCVEPageOnly := false
	if worker.config.TestMode.Enable {
		updateAll = worker.config.TestMode.UpdateScores.UpdateAll
		getFirstCVEOnly = worker.config.TestMode.UpdateScores.GetFirstCVEOnly
		updateFirstCVEOnly = worker.config.TestMode.UpdateScores.UpdateFirstCVEOnly
		getFirstCVEPageOnly = worker.config.TestMode.UpdateScores.GetFirstCVEPageOnly
		updateFirstCVEPageOnly = worker.config.TestMode.UpdateScores.UpdateFirstCVEPageOnly

		if !updateAll && !(getFirstCVEOnly || updateFirstCVEOnly || getFirstCVEPageOnly || updateFirstCVEPageOnly) {
			getFirstCVEOnly = true
			updateFirstCVEOnly = true
		}

		if getFirstCVEOnly || updateFirstCVEOnly || getFirstCVEPageOnly || updateFirstCVEPageOnly {
			if updateAll {
				worker.logger.Debugf("If you want to update all CVEs, you must disable all 'first only' config")
			}
			updateAll = false
		}

		worker.logger.Debugf("Update all: %v", updateAll)
		worker.logger.Debugf("Get First CVE only: %v", getFirstCVEOnly)
		worker.logger.Debugf("Update First CVE only: %v", updateFirstCVEOnly)
		worker.logger.Debugf("Get First CVE page only: %v", getFirstCVEPageOnly)
		worker.logger.Debugf("Update First CVE page only: %v", updateFirstCVEPageOnly)
	}

	group.Go(func() error {
		// Step 1: query CVEs
		// Step 2: For each responsed CVE, get CVE_ID from DB, and put Update score request to a bulk
		// Step 3: Execute the bulk Update

		totalResult := -1
		startIndex := 0
		retry := 0
		base_url := "https://services.nvd.nist.gov/rest/json/cves/2.0?startIndex=%d"

		if worker.config.TestMode.Enable {
			startIndex = worker.config.TestMode.UpdateScores.StartIndex
			worker.logger.Debugf("Start index: %d", startIndex)
		}

		for {
			if listenContextDone(ctx) {
				worker.logger.Info("Close goroutine while crawling.")
				return nil
			}

			if totalResult != -1 && startIndex >= totalResult {
				break
			}

			url := fmt.Sprintf(base_url, startIndex)
			worker.logger.Debugf("URL: %s", url)
			response, err := worker.GetCVE(url)
			if err != nil {
				worker.logger.Errorf("Failed to get CVEs. URL: %s . Error: %v", url, err)
				if retry >= 5 {
					return err
				}
				retry++
				worker.logger.Debugf("Retry %d time(s): %s", retry, url)
				continue
			}

			// success
			retry = 0
			totalResult = response.TotalResults
			worker.logger.Debugf("Got %d CVEs, startIndex %d, total %d!",
				len(response.Vulnerabilities), startIndex, totalResult)
			startIndex = response.StartIndex + response.ResultsPerPage

			// Update scores...
			updates := make([]es.UpdateDocument, 0)
			nameList := make([]string, 0)
			for _, vuln := range response.Vulnerabilities {
				cve := vuln.CVE
				// worker.logger.Debug(cve.ID)
				saved, err := worker.elastic.CVE().GetByName(ctx, cve.ID)
				if err != nil {
					if err.Error() == es.NotFoundError {
						// worker.logger.Warningf("CVE not found: %s", cve.ID)
						continue
					}
					worker.logger.Errorf("Failed to get cve from DB. CVE: %s. Error: %v", cve.ID, err)
					continue
				}

				cnaSeverity, cnaVersion, cnaScore := cve.GetLatestCVSS(defs.SourceTypeSecondary)
				if cnaSeverity != defs.SeverityCodeUnknown {
					saved.Score.CNA.Severity = cnaSeverity
					saved.Score.CNA.Version = cnaVersion
					saved.Score.CNA.Score = cnaScore
				}
				// Save NVD
				nvdSeverity, nvdVersion, nvdScore := cve.GetLatestCVSS(defs.SourceTypePrimary)
				saved.Score.Global = model.CVEMetric{}
				if nvdSeverity != defs.SeverityCodeUnknown {
					saved.Score.Global.Severity = nvdSeverity
					saved.Score.Global.Version = nvdVersion
					saved.Score.Global.Score = nvdScore
				}
				// Score NVD
				saved.Score.CVSS2 = model.CVEMetric{}
				saved.Score.CVSS3 = model.CVEMetric{}
				saved.Score.CVSS4 = model.CVEMetric{}
				if ok, score40 := cve.GetCVSSV4(defs.SourceTypePrimary); ok {
					saved.Score.CVSS4 = *score40
				}
				if ok, score3 := cve.GetCVSSV3(defs.SourceTypePrimary); ok {
					saved.Score.CVSS3 = *score3
				}
				if ok, score20 := cve.GetCVSSV2(defs.SourceTypePrimary); ok {
					saved.Score.CVSS2 = *score20
				}
				updates = append(updates, es.UpdateDocument{
					ID: saved.ID,
					Update: map[string]interface{}{
						"score": saved.Score,
					},
				})
				nameList = append(nameList, saved.Name)
				if getFirstCVEOnly || updateFirstCVEOnly {
					break
				}
			}

			if worker.config.TestMode.Enable && !updateAll {
				worker.logger.Infof("About to handle %d CVE(s): %v ", len(nameList), nameList)
			}

			if !worker.config.TestMode.Enable ||
				updateAll ||
				updateFirstCVEOnly || updateFirstCVEPageOnly {
				err = worker.elastic.CVE().UpdateMany(ctx, updates)
				if err != nil {
					worker.logger.Errorf("Failed to update many. Offset: %d. Error: %v", startIndex, err)
				} else {
					worker.logger.Infof("Successfully updated %d CVEs", len(updates))
				}
			}

			if getFirstCVEOnly || updateFirstCVEOnly ||
				getFirstCVEPageOnly || updateFirstCVEPageOnly {
				break
			}
		}

		worker.logger.Info("DONE process updating CVE scores!")
		return nil
	})

	if err := group.Wait(); err != nil {
		worker.logger.Errorf("Error occurred: %v", err)
	}

}

func (worker *cveUpdateScores) GetCVE(url string) (*CVEResponse, error) {
	// Wait for rate limit
	if err := worker.limiter.Wait(context.Background()); err != nil {
		worker.logger.Errorf("Error waiting for limiter: %v", err)
	}

	res, err := worker.client.R().
		SetHeader("apiKey", worker.config.NVDKey).
		Get(url)
	if err != nil {
		worker.logger.Errorf("get url (%s) error, reason: %v", worker.config.NVDApi, err)
		return nil, err
	}
	if res.StatusCode() != rest.StatusOK {
		worker.logger.Errorf("get url (%s) return code %d", url, res.StatusCode())
		return nil, errors.New(fmt.Sprintf("status code: %d", res.StatusCode()))
	}

	var cve CVEResponse
	err = json.Unmarshal(res.Body(), &cve)
	if err != nil {
		worker.logger.Errorf("Unmarshal cve error, reason: %v", err)
		return nil, err
	}

	return &cve, nil
}

func listenContextDone(ctx context.Context) bool {
	select {
	case <-ctx.Done():
		return true
	default:
		return false
	}
}
