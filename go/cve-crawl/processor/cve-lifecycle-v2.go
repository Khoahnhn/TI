package processor

import (
	"context"
	"cve-crawler/adapter/elastic"
	"cve-crawler/defs"
	"cve-crawler/model"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"math"
	"net/url"
	"runtime"
	"slices"
	"strings"
	"time"

	"gitlab.viettelcyber.com/awesome-threat/library/adapter/kafka"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"gitlab.viettelcyber.com/awesome-threat/library/hash"
	vul_priority "gitlab.viettelcyber.com/awesome-threat/vulpriority-component/model"
	"golang.org/x/sync/errgroup"
)

type cveLifecycleV2 struct {
	name            string
	context         context.Context
	elastic         elastic.EnrichmentRepository
	queue           rabbit.Service
	kafkaConsumer   kafka.Consumer
	config          model.WorkerConfig
	outputEventChan chan *model.CVELifecycle
}

func newCveLifecycleV2(ctx context.Context, conf model.WorkerConfig) Processor {
	worker := cveLifecycleV2{name: defs.WorkerCveParser, context: ctx, config: conf}
	worker.elastic = elastic.NewEnrichmentRepository(worker.config.Adapter.Elastic.Enrichment)
	worker.queue = rabbit.NewService(worker.context, worker.config.Adapter.Rabbit.Crawler, nil)
	worker.outputEventChan = make(chan *model.CVELifecycle, 1000)
	kafkaConfig := worker.config.Adapter.Kafka
	topics := strings.Join([]string{
		kafkaConfig.Topic.VulPriorityCisa,
		kafkaConfig.Topic.CVELifecycleInput,
	}, ",")
	consumerConfig := kafkaConfig.Consumer
	consumerConfig.Topics = topics
	consumer, err := kafka.NewConsumer(ctx, consumerConfig, worker.handleKafkaMessage)
	if err != nil {
		panic(err)
	}
	worker.kafkaConsumer = consumer
	return &worker
}

func (worker *cveLifecycleV2) Start() {
	// Prepare
	worker.Prepare()
	// Start
	if worker.config.App.Core == 0 {
		worker.config.App.Core = runtime.NumCPU()
	}
	group, ctx := errgroup.WithContext(worker.context)

	group.Go(func() error {
		return worker.insertLifecycleEvent(ctx)
	})

	// Consume from rabbitMQ
	consumerGroup, consumerCtx := errgroup.WithContext(ctx)
	// TODO: Assumption: cve-raw data is already inserted to ES when cve-name is pushed to lifecycle queue
	consumerGroup.Go(func() error {
		return worker.consumeQueueLifeCycle(consumerCtx)
	})

	// Consume kafka data from vulnerability-priority repos
	consumerGroup.Go(func() error {
		return worker.consumeKafka(consumerCtx)
	})

	if err := consumerGroup.Wait(); err != nil {
		log.Printf("[error] cveLifecycle.consumerGroup.Wait: %v", err)
	}

	log.Println("[info] consumers exited")
	close(worker.outputEventChan)

	if err := group.Wait(); err != nil {
		log.Printf("[error] cveLifecycle.group.Wait: %v", err)
	}
}

func (worker *cveLifecycleV2) consumeQueueLifeCycle(ctx context.Context) error {
	wg, ctx := errgroup.WithContext(ctx)

	log.Println("[info] waiting for data from lifecycle-queue (rabbit)")
	// Get data from queue. Blocks until ctx.Done() is received or an error occured
	queueErr := worker.queue.Consume(defs.QueueCveLifecycle, false, 1, func(data []byte) error {
		log.Printf("[info] received for queue: %s, %s", defs.QueueCveLifecycle, string(data))
		wg.Go(func() error {
			return worker.handleQueueLifeCycle(ctx, string(data))
		})
		// Success
		return nil
	})
	if err := wg.Wait(); err != nil {
		return err
	}
	return queueErr
}

func (worker *cveLifecycleV2) consumeKafka(ctx context.Context) error {
	<-ctx.Done()
	worker.kafkaConsumer.Close()

	return nil
}

func (worker *cveLifecycleV2) insertLifecycleEvent(ctx context.Context) error {
	for event := range worker.outputEventChan {
		if event == nil {
			continue
		}
		log.Printf("[info] received event %v:%v for insert", event.CVECode, event.Event)

		lifecycleLogstash := model.CVELifecycleLogstash{
			CVELifecycle: *event,
			Metadata: model.Metadata{
				ID:    event.ID,
				Index: defs.IndexCveLifeCycle,
				Type:  "cve-lifecycle",
			},
		}
		bts, err := json.Marshal(lifecycleLogstash)
		if err != nil {
			log.Printf("[error] failed to marshal logstash event %v: %v", *event, err)
			continue
		}
		if err := worker.queue.Publish("", defs.QueueLogstashLifecycle, rabbit.Message{
			Body:        bts,
			ContentType: rabbit.MIMEApplicationJSON,
			Mode:        rabbit.Persistent,
			Priority:    0,
		}); err != nil {
			log.Printf("[error] failed to publish logstash event %v: %v", *event, err)
			continue
		}
		log.Printf("[info] published event to logstash %v:%v", event.CVECode, event.Event)
	}
	return nil
}

func (worker *cveLifecycleV2) handleQueueLifeCycle(ctx context.Context, cveName string) error {
	query := map[string]any{
		"term": map[string]any{
			"cve.CVE_data_meta.ID": map[string]any{
				"value": cveName,
			},
		},
	}
	cveRaw, err := worker.elastic.CVERaw().Find(ctx, query, []string{}, 0, 1)
	if err != nil {
		log.Printf("[error] failed to get raw-cve with id %v: %v", cveName, err)
		return err
	}
	if len(cveRaw) == 0 {
		log.Printf("[error] no raw-cve with id %v", cveName)
		return errors.New("no document")
	}

	worker.outputEventChan <- worker.generateEventCVE(cveRaw[0])
	worker.outputEventChan <- worker.generateEventMitigation(cveRaw[0])

	return nil
}

func (worker *cveLifecycleV2) handleKafkaMessage(topic string, _, value []byte) error {
	log.Println("[info] received kafka message from topic: ", topic)
	var event *model.CVELifecycle = nil

	kafkaTopics := worker.config.Adapter.Kafka.Topic
	switch topic {
	case kafkaTopics.VulPriorityCisa:
		event = worker.handleCisaKafka(value)
	case kafkaTopics.CVELifecycleInput:
		event = worker.handleOstKafka(value)
	}
	worker.outputEventChan <- event
	return nil
}

func (worker *cveLifecycleV2) handleCisaKafka(bts []byte) *model.CVELifecycle {
	cisa := vul_priority.CISA{}
	if err := json.Unmarshal(bts, &cisa); err != nil {
		log.Printf("[error] failed to unmarshal CISA message: %v", string(bts))
		return nil
	}
	return worker.generateEventExploit(&cisa)
}

func (worker *cveLifecycleV2) handleOstKafka(bts []byte) *model.CVELifecycle {
	ost := model.LifecycleOstKafkaInput{}
	if err := json.Unmarshal(bts, &ost); err != nil {
		log.Printf("[error] failed to unmarshal CISA message: %v", string(bts))
		return nil
	}
	return worker.generateEventOst(&ost)
}

func (worker *cveLifecycleV2) generateEventCVE(cveRaw *model.CVERaw) *model.CVELifecycle {
	created, err := time.ParseInLocation(defs.TIMEFORMAT_NVD, cveRaw.PublishedDate, time.UTC)
	cveCode := cveRaw.Detail.Metadata.ID
	if err != nil {
		log.Printf("[error] failed to parse published_date for cve %v: %v", cveCode, cveRaw.PublishedDate)
		return nil
	}
	created = created.UTC()
	event := model.CVELifecycle{
		CVEId:   cveRaw.GetID(),
		CVECode: cveCode,
		Created: created.UnixMilli(),
		Event:   model.CVE_LIFECYCLE_CVE,
		References: []string{
			fmt.Sprintf("https://nvd.nist.gov/vuln/detail/%s", cveCode),
		},
	}
	event.GenerateId()

	return &event
}

func (worker *cveLifecycleV2) generateEventMitigation(cveRaw *model.CVERaw) *model.CVELifecycle {
	created, err := time.ParseInLocation(defs.TIMEFORMAT_NVD, cveRaw.PublishedDate, time.UTC)
	cveCode := cveRaw.Detail.Metadata.ID
	if err != nil {
		log.Printf("[error] failed to parse published_date for cve %v: %v", cveCode, cveRaw.PublishedDate)
		return nil
	}
	created = created.UTC()
	references := []string{}
	for _, ref := range cveRaw.Detail.References.Data {
		if len(ref.Tags) == 0 {
			// Nếu url nằm trong blacklist (github, vuldb, exploitdb) => Bỏ qua link
			parsedUrl, err := url.Parse(ref.Url)
			if err != nil {
				log.Printf("[error] failed to parse url \"%v\": %v", ref.Url, err.Error())
				continue
			}
			if !slices.Contains(defs.LifecycleMitigationHostBlacklist, parsedUrl.Hostname()) {
				references = append(references, ref.Url)
			}
		} else {
			// Nếu có tag Vendor advisory thì thu thập
			if slices.Contains(ref.Tags, "Vendor Advisory") {
				references = append(references, ref.Url)
			}
		}
	}

	event := &model.CVELifecycle{
		CVEId:      cveRaw.GetID(),
		CVECode:    cveCode,
		Created:    created.UnixMilli(),
		Event:      model.CVE_LIFECYCLE_MITIGATION,
		References: references,
	}
	event.GenerateId()
	return event
}

func (worker *cveLifecycleV2) generateEventExploit(cisaData *vul_priority.CISA) *model.CVELifecycle {
	created, err := time.ParseInLocation(defs.TIMEFORMAT_CISA, cisaData.DateAdded, time.UTC)
	if err != nil {
		log.Printf("[error] failed to parse date_added for cve %v: %v", cisaData.CVE, cisaData.DateAdded)
		return nil
	}
	created = created.UTC()

	event := &model.CVELifecycle{
		CVEId:      hash.SHA1(cisaData.CVE),
		CVECode:    cisaData.CVE,
		Created:    created.UnixMilli(),
		Event:      model.CVE_LIFECYCLE_EXPLOIT,
		References: []string{cisaData.URL},
	}
	event.GenerateId()

	return event
}

func (worker *cveLifecycleV2) generateEventOst(ostData *model.LifecycleOstKafkaInput) *model.CVELifecycle {
	if ostData.PublishDate == math.MaxInt64 || ostData.PublishDate == 0 {
		log.Printf("[error] corrupted published date for cve %v, event ost: %v", ostData.CveName, ostData.PublishDate)
		return nil
	}
	event := &model.CVELifecycle{
		CVEId:      hash.SHA1(ostData.CveName),
		CVECode:    ostData.CveName,
		Created:    ostData.PublishDate,
		Event:      model.CVE_LIFECYCLE_OST,
		References: ostData.Urls,
	}
	event.GenerateId()

	return event
}

func (worker *cveLifecycleV2) Prepare() {
	if err := worker.queue.DeclareQueue(defs.QueueCveLifecycle, true, 0, 0); err != nil {
		panic(err)
	}

	if err := worker.queue.DeclareQueue(defs.QueueLogstashLifecycle, true, 0, 0); err != nil {
		panic(err)
	}
}
