package processor

import (
	"context"
	"crypto/tls"
	"cve-crawler/adapter/elastic"
	"cve-crawler/defs"
	"cve-crawler/model"
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"sync"
	"time"

	"github.com/go-resty/resty/v2"
	es "gitlab.viettelcyber.com/awesome-threat/library/adapter/elastic"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/hash"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"golang.org/x/sync/errgroup"
)

type cveLifecycle struct {
	name    string
	context context.Context
	logger  pencil.Logger
	elastic elastic.EnrichmentRepository
	queue   rabbit.Service
	config  model.WorkerConfig
	client  *resty.Client
	mutex   *sync.Mutex
}

type (
	CVEHistoryResponse struct {
		StartIndex     int                `json:"startIndex"`
		TotalResults   int                `json:"totalResults"`
		ResultsPerPage int                `json:"resultsPerPage"`
		Changes        []CVEHistoryChange `json:"cveChanges"`
	}
	CVEHistoryChange struct {
		Change struct {
			CVEID            string `json:"cveId"`
			EventName        string `json:"eventName"`
			CVEChangeId      string `json:"cveChangeId"`
			SourceIdentifier string `json:"sourceIdentifier"`
			Created          string `json:"created"`
		} `json:"change"`
	}
	CisaKEVEntry struct {
		CVEID     string
		DateAdded string
	}
)

func newCveLifecycle(ctx context.Context, conf model.WorkerConfig) Processor {
	logger, _ := pencil.New(defs.WorkerCveParser, pencil.DebugLevel, true, os.Stdout)
	worker := cveLifecycle{name: defs.WorkerCveParser, context: ctx, logger: logger, config: conf, mutex: &sync.Mutex{}}
	// Repository
	worker.elastic = elastic.NewEnrichmentRepository(worker.config.Adapter.Elastic.Enrichment)
	worker.queue = rabbit.NewService(worker.context, worker.config.Adapter.Rabbit.Crawler, nil)
	client := resty.New()
	client.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})
	client.SetTimeout(time.Duration(clock.Minute * clock.Duration(worker.config.App.Timeout)))
	if worker.config.App.Proxy.Enable {
		client.SetProxy(worker.config.App.Proxy.String())
	}
	worker.client = client
	// Success
	return &worker
}

func (worker *cveLifecycle) Start() {
	// Prepare
	worker.Prepare()
	// Start
	if worker.config.App.Core == 0 {
		worker.config.App.Core = runtime.NumCPU()
	}
	group, ctx := errgroup.WithContext(worker.context)
	// Consume
	for i := 0; i < worker.config.App.Core; i++ {
		func(i int) {
			group.Go(func() error {
				worker.logger.Infof(" [*] waiting for queue: %s - coreId: %d", defs.QueueCveLifecycle, i)
				err := worker.queue.Consume(defs.QueueCveLifecycle, false, 1, func(data []byte) error {
					worker.logger.Infof(" [*] received for queue: %s - coreId: %d, %s", defs.QueueCveLifecycle, i, string(data))
					var raw model.CVE
					raw.Name = string(data)
					worker.mutex.Lock()
					worker.logger.Infof("start lock :%s", raw.Name)
					defer func() {
						worker.logger.Infof("unlock %s", raw.Name)
						worker.mutex.Unlock()
					}()
					worker.logger.Infof("process: %s - core: %d", string(data), i)

					group, eventCtx := errgroup.WithContext(ctx)

					group.Go(func() error {
						return worker.handleEvents(raw.Name, eventCtx)
					})

					group.Go(func() error {
						return worker.handleCveEpssHistory(raw.Name, eventCtx)
					})

					if err := group.Wait(); err != nil {
						return worker.HandleError(err, data)
					}

					worker.logger.Infof("process: %s success", raw.Name)
					// Success
					return nil
				})
				// Success
				return err
			})
		}(i)
	}
	if err := group.Wait(); err != nil {
		worker.logger.Errorf("cveLifecycle.group.Wait", err)
	}
}

func (worker *cveLifecycle) HandleError(err error, bts []byte) error {
	worker.logger.Errorf("process CVE error, reason: %v", err)
	// Success
	return nil
}

func (worker *cveLifecycle) Prepare() {
	if err := worker.queue.DeclareQueue(defs.QueueCveLifecycle, true, 0, 0); err != nil {
		panic(err)
	}
}

func (worker *cveLifecycle) handleEvents(cveName string, ctx context.Context) error {
	group, _ := errgroup.WithContext(ctx)

	eventsChan := make(chan *model.CVELifecycle, 10)

	// Event CVE + Exploit
	group.Go(func() error {
		return worker.handleCveOrg(ctx, cveName, eventsChan)
	})

	if err := group.Wait(); err != nil {
		return err
	}

	// TODO: add remaining events

	close(eventsChan)
	events := make([]*model.CVELifecycle, 0)
	for event := range eventsChan {
		events = append(events, event)
	}
	err := worker.elastic.CVELifecycle().StoreMany(ctx, events)
	if err != nil {
		return err
	}
	return nil
}

func (worker *cveLifecycle) handleCveOrg(ctx context.Context, cveName string, eventsChan chan *model.CVELifecycle) error {
	response, err := worker.scanCveorg(cveName)
	if err != nil {
		worker.logger.Errorf("failed to scan cve.org: %v", err)
		return err
	}

	if event, err := worker.generateCVEEvent(cveName, response); err != nil {
		worker.logger.Errorf("failed to generate lifecycle cve event: %v", err)
	} else {
		eventsChan <- event
	}

	if event, err := worker.generateExploitEvent(cveName, response); err != nil {
		worker.logger.Errorf("failed to generate lifecycle cve event: %v", err)
	} else if event != nil {
		eventsChan <- event
	}

	return nil
}

func (worker *cveLifecycle) generateCVEEvent(cveName string, cveorgResult model.CveorgCveApiResponse) (*model.CVELifecycle, error) {
	id := hash.SHA1(cveName)
	created, err := time.Parse(defs.CVEORG_TIME_FORMAT, cveorgResult.CveMetadata.DatePublished)
	if err != nil {
		return nil, err
	}

	event := model.CVELifecycle{
		CVEId:      id,
		CVECode:    cveName,
		Created:    created.UnixMilli(),
		Event:      model.CVE_LIFECYCLE_CVE,
		References: []string{fmt.Sprintf(defs.CVE_LIFECYCLE_REFS_CVEORG, cveName)},
	}

	return &event, nil
}

func (worker *cveLifecycle) generateExploitEvent(cveName string, cveorgResult model.CveorgCveApiResponse) (*model.CVELifecycle, error) {
	for _, adp := range cveorgResult.Containers.Adp {
		for _, metric := range adp.Metrics {
			if metric.Other.Type != defs.CVEORG_METRICTYPE_KEV {
				continue
			}
			dateAdded, ok := metric.Other.Content["dateAdded"]
			if !ok {
				return nil, fmt.Errorf("missing field dateAdded in KEV data %v", cveName)
			}

			id := hash.SHA1(cveName)
			created, err := time.Parse(defs.CVEORG_DATE_FORMAT, dateAdded.(string))
			if err != nil {
				return nil, err
			}

			return &model.CVELifecycle{
				CVEId:      id,
				CVECode:    cveName,
				Created:    created.UnixMilli(),
				Event:      model.CVE_LIFECYCLE_EXPLOIT,
				References: []string{fmt.Sprintf(defs.CVE_LIFECYCLE_REFS_CVEORG, cveName)},
			}, nil
		}
	}
	return nil, nil
}

func (worker *cveLifecycle) scanCveorg(cveName string) (response model.CveorgCveApiResponse, err error) {
	url := fmt.Sprintf(worker.config.CveorgCveApi, cveName)

	jsonResponse, err := worker.client.R().Get(url)
	if err != nil {
		return response, err
	}

	if err := json.Unmarshal(jsonResponse.Body(), &response); err != nil {
		return response, err
	}

	return response, nil
}

func (worker *cveLifecycle) handleCveEpssHistory(cveName string, ctx context.Context) error {
	url := fmt.Sprintf("%s?cve=%s", worker.config.FirstCveEpssAPI, cveName)
	respJson, err := worker.client.R().Get(url)
	if err != nil {
		return err
	}

	var cveEpssResponse model.FirstOrgCveEpssResponse
	if err := json.Unmarshal(respJson.Body(), &cveEpssResponse); err != nil {
		return err
	}
	if cveEpssResponse.Total == 0 {
		return fmt.Errorf("first.org api, cve %v not found", cveName)
	}

	cveEpss := cveEpssResponse.Data[0]

	oldCve, err := worker.elastic.CVE().GetByName(ctx, cveName)
	if err != nil {
		return err
	}
	newScore, err := strconv.ParseFloat(cveEpss.Epss, 64)
	if err != nil {
		return err
	}
	newPercentile, err := strconv.ParseFloat(cveEpss.Percentile, 64)
	if err != nil {
		return err
	}

	if (oldCve.Epss.Score == nil) ||
		(oldCve.Epss.Score != nil && *oldCve.Epss.Score == newScore) {
		worker.logger.Infof("%v: EPSS score didn't change", cveName)
		return nil
	}
	updateDoc := es.UpdateDocument{
		ID: oldCve.ID,
		Update: map[string]any{
			"epss": model.CVEEpss{
				Score:      &newScore,
				Percentile: &newPercentile,
			},
		},
	}
	err = worker.elastic.CVE().UpdateMany(ctx, []es.UpdateDocument{updateDoc})
	if err != nil {
		return err
	}
	err = worker.elastic.CVEEpssHistory().Store(ctx, &model.CveEpssHistory{
		Id:            oldCve.ID,
		CveName:       cveName,
		Date:          uint64(time.Now().UnixMilli()),
		Editor:        defs.EditorUserName,
		OldScore:      oldCve.Epss.Score,
		NewScore:      &newScore,
		OldPercentile: oldCve.Epss.Percentile,
		NewPercentile: &newPercentile,
	})
	if err != nil {
		return err
	}

	return nil
}

func insertVtiLifeCycle(db elastic.CVELifecycleRepository, event model.CVELifecycleEvent, cveName string, created int64) error {
	if cveName == "" {
		return fmt.Errorf("cve %s, with event %v empty", cveName, event)
	}
	cveId := hash.SHA1(cveName)
	now := time.Now().UnixMilli()
	if created == 0 {
		created = now
	}
	doc := &model.CVELifecycle{
		CVEId:   cveId,
		CVECode: cveName,
		Created: created,
		Event:   event,
	}
	doc.GenerateId()
	return db.Store(context.Background(), doc)
}
