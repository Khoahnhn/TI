package processor

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"runtime"
	"slices"
	"strings"
	"time"

	"cve-crawler/adapter/elastic"

	"gitlab.viettelcyber.com/awesome-threat/library/rest"
	"gitlab.viettelcyber.com/awesome-threat/library/slice"

	"github.com/go-resty/resty/v2"
	es "gitlab.viettelcyber.com/awesome-threat/library/adapter/elastic"
	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"gitlab.viettelcyber.com/awesome-threat/library/clock"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"golang.org/x/sync/errgroup"

	"cve-crawler/defs"
	"cve-crawler/model"
)

type cveRecheck struct {
	name    string
	context context.Context
	logger  pencil.Logger
	elastic elastic.EnrichmentRepository
	queue   rabbit.Service
	config  model.WorkerConfig
	client  *resty.Client
}

func newCVERecheck(ctx context.Context, conf model.WorkerConfig) Processor {
	logger, _ := pencil.New(defs.WorkerCveRecheck, pencil.DebugLevel, true, os.Stdout)
	worker := cveRecheck{name: defs.WorkerCveRecheck, context: ctx, logger: logger, config: conf}
	// Repository
	worker.elastic = elastic.NewEnrichmentRepository(worker.config.Adapter.Elastic.Enrichment)
	worker.queue = rabbit.NewService(worker.context, worker.config.Adapter.Rabbit.Crawler, nil)

	client := resty.New()
	client.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})
	client.SetTimeout(time.Duration(clock.Minute * clock.Duration(worker.config.App.Timeout)))
	if worker.config.App.Proxy.Enable {
		client.SetProxy(worker.config.App.Proxy.String())
	}
	worker.client = client
	// Success
	return &worker
}

func (worker *cveRecheck) Start() {
	worker.logger.Debugf("Start worker %s", defs.WorkerCveRecheck)
	if worker.config.TestMode.Enable {
		worker.logger.Debug("Test mode: enabled")
		worker.logger.Debugf("Target CVEs: %v", worker.config.TestMode.Recheck.TargetCVEs)
		worker.logger.Debugf("Recheck in range: %v months ago", worker.config.TestMode.Recheck.MonthsAgo)
	} else {
		worker.logger.Debugf("Test mode: disable")
	}
	// Prepare
	worker.Prepare()
	// Start
	if worker.config.App.Core == 0 {
		worker.config.App.Core = runtime.NumCPU()
	}
	group, ctx := errgroup.WithContext(worker.context)
	group.Go(func() error {
		queue := rabbit.NewService(ctx, worker.config.Adapter.Rabbit.Crawler, nil)
		delay := clock.Minute * clock.Duration(worker.config.App.Schedule)
		for {
			now, _ := clock.Now(clock.UTC)
			monthsAgo := 1
			if worker.config.TestMode.Enable &&
				worker.config.TestMode.Recheck.MonthsAgo > 1 {
				monthsAgo = worker.config.TestMode.Recheck.MonthsAgo
			}
			start := now.AddDate(0, -monthsAgo, 0)
			worker.logger.Infof("start recheck: %s", clock.Format(now, clock.FormatHumanZ))
			query := map[string]interface{}{
				"bool": map[string]interface{}{
					"filter": []interface{}{
						map[string]interface{}{
							"term": map[string]interface{}{
								"isRecheck": true,
							},
						},
						map[string]interface{}{
							"range": map[string]interface{}{
								"latest": map[string]interface{}{
									"gte": start,
								},
							},
						},
					},
					"must_not": []interface{}{
						map[string]interface{}{
							"term": map[string]interface{}{
								"status": defs.StatusCodeApproved,
							},
						},
					},
				},
			}
			documents, err := worker.elastic.CVE().FindAll(ctx, query, []string{})
			if err != nil {
				worker.logger.Errorf("[recheck]get CVE error, reason: %v", err)
				if err.Error() == es.NotFoundError {
					now, _ = clock.Now(clock.UTC)
					next := now.Add(time.Duration(delay))
					worker.logger.Infof("next time recheck: %s", clock.Format(next, clock.FormatHumanZ))
					clock.Sleep(delay)
					continue
				}
				documents = make([]*model.CVE, 0)
			}
			worker.logger.Infof("[recheck]process total cve: %d", len(documents))
			for _, it := range documents {
				// check in Test mode, ignore unsupported CVEs
				if worker.config.TestMode.Enable &&
					!slices.Contains(worker.config.TestMode.Recheck.TargetCVEs, it.Name) {
					continue
				}

				worker.logger.Infof("[recheck]process cve %s", it.Name)
				clock.Sleep(clock.Second * clock.Duration(worker.config.App.Duration))
				raw, err := worker.GetCVE(it.Name)
				if err != nil {
					worker.logger.Errorf("[recheck]get CVE error, reason: %v", err)
					continue
				}

				if raw.VulStatus == defs.VulnerabilityStatusRejected {
					worker.logger.Debugf("[recheck]process cve %s stop, reason: nvd status %s", it.Name, raw.VulStatus)
					saved, err := worker.elastic.CVE().GetByID(ctx, raw.GetID())
					if err != nil {
						if err.Error() != es.NotFoundError {
							worker.logger.Errorf("[recheck]get CVE error, reason: %v", err)
							continue
						}
					}
					saved.IsRecheck = false
					meta := &model.CVELogstash{
						CVE: *saved,
						Metadata: model.Metadata{
							ID:    saved.ID,
							Index: defs.IndexCVE,
							Type:  defs.TypeCve,
						},
					}
					metaBts, _ := json.Marshal(meta)
					if err := queue.Publish("", defs.QueueLogstashCve, rabbit.Message{
						Body:        metaBts,
						ContentType: rabbit.MIMEApplicationJSON,
						Mode:        rabbit.Persistent,
						Priority:    0,
					}); err != nil {
						worker.logger.Errorf("queue.Publish failed, reason: %v", err)
					}
					continue
				}
				modified := clock.UnixMilli(raw.GetLastModified())
				lang := &model.CVELang{
					ID:        raw.GetID(),
					Reference: []string{},
					Patch:     []string{},
					Lang:      defs.LangEn,
				}
				cnaSeverity, cnaVersion, cnaScore := raw.GetLatestCVSS(defs.SourceTypeSecondary)
				saved, err := worker.elastic.CVE().GetByID(ctx, raw.GetID())
				if err != nil {
					if err.Error() != es.NotFoundError {
						worker.logger.Errorf("worker.elastic.CVE.GetByID failed, reason: %v", err)
						continue
					}
					now, _ := clock.Now(clock.Local)
					nowUnix := clock.UnixMilli(now)
					saved = &model.CVE{
						Status:   defs.StatusCodeUnknown,
						Created:  nowUnix,
						Modified: modified,
						Crawled:  nowUnix,
						Checklist: model.CVEChecklist{
							Metric: model.CVECheckListMetric{
								Affect:    defs.PointNil,
								Exploit:   defs.PointNil,
								Patch:     defs.PointNil,
								Ability:   defs.PointNil,
								Condition: defs.PointNil,
							},
							Point: 0,
						},
						Match:    raw.GetProducts(),
						Approved: modified,
						Source:   "nvd",
						Creator:  "VTI system",
					}
					// Language
					if lang.Raw == "" {
						description := strings.Join(raw.GetDescriptions(), "\n")
						lang.Raw = description
						lang.Description = description
						saved.Searchable.EN.Description = description
						saved.Searchable.EN.Reference = raw.GetReference()
					}
					lang.Reference = raw.GetReference()
					lang.Patch = raw.GetPatch()
				} else {
					if modified <= saved.Latest {
						worker.logger.Debugf("[recheck] process cve %s stop, reason: modified %v <= last modified %v",
							it.Name, modified, saved.Latest)
						continue
					}
					currentCVE := *saved

					if saved.Status == defs.StatusCodeUnknown {
						now, _ := clock.Now(clock.Local)
						saved.Modified = clock.UnixMilli(now)
					}

					// Get saved Lang
					lang, err = worker.elastic.CVELanguage(defs.LangEn).GetByID(ctx, saved.ID)
					if err != nil {
						if err.Error() != es.NotFoundError {
							worker.logger.Errorf("worker.elastic.CVELanguage.GetByID failed, reason: %v", err)
							continue
						}
						lang = &model.CVELang{
							ID:        saved.ID,
							Reference: []string{},
							Patch:     []string{},
							Lang:      defs.LangEn,
						}
					}
					saved.Match = raw.GetProducts()
					history, err := worker.elastic.CVEHistory().GetCVEHistoryByCVEIdAndAction(ctx, saved.ID)
					if err != nil && err.Error() != es.NotFoundError {
						worker.logger.Errorf("[recheck]get history error, reason: %v", err)
						continue
					}

					if saved.Status == defs.StatusCodeReject || (len(history) != 0 && (saved.Status == defs.StatusCodeNew || saved.Status == defs.StatusCodeApproved || saved.Status == defs.StatusCodeUnknown)) {
						for _, it := range currentCVE.Match {
							if !slice.String(saved.Match).Contains(it) {
								saved.Match = append(saved.Match, it)
							}
						}
						if saved.Status != defs.StatusCodeReject {
							now, _ := clock.Now(clock.Local)
							saved.Modified = clock.UnixMilli(now)
						}
					} else {
						// Language
						description := strings.Join(raw.GetDescriptions(), "\n")
						lang.Raw = description
						lang.Description = description
						saved.Searchable.EN.Description = description
						saved.Searchable.EN.Reference = raw.GetReference()
						lang.Reference = raw.GetReference()
						lang.Patch = raw.GetPatch()

						if saved.Status == defs.StatusCodeNew {
							currentSeverity := currentCVE.Score.Global.Severity
							if currentSeverity != cnaSeverity && (cnaSeverity == defs.SeverityCodeHigh || cnaSeverity == defs.SeverityCodeCritical) {
								now, _ := clock.Now(clock.Local)
								saved.Modified = clock.UnixMilli(now)
							}
						}

						if saved.Status == defs.StatusCodeUnknown {
							now, _ := clock.Now(clock.Local)
							saved.Modified = clock.UnixMilli(now)
						}
					}
				}
				// Create
				saved.ID = raw.GetID()
				saved.Name = raw.ID
				saved.Latest = clock.UnixMilli(raw.GetLastModified())
				saved.Published = clock.UnixMilli(raw.GetPublished())
				if saved.Checker == "" {
					saved.Checker = defs.DefaultChecker
				}

				saved.Vendor = raw.GetVendor(saved.Match)
				if len(saved.Vendor) == 0 {
					saved.Vendor = []string{defs.TitleVendorUnknown}
				}
				if len(saved.Customer) == 0 {
					saved.Customer = []string{}
				}

				// Save CNA
				saved.IsRecheck = false
				if cnaSeverity == defs.SeverityCodeUnknown {
					saved.IsRecheck = true
				} else {
					saved.Score.CNA.Severity = cnaSeverity
					saved.Score.CNA.Version = cnaVersion
					saved.Score.CNA.Score = cnaScore
				}
				worker.logger.Infof("cve: %s, isRecheck: %v", saved.Name, saved.IsRecheck)
				// Save NVD
				nvdSeverity, nvdVersion, nvdScore := raw.GetLatestCVSS(defs.SourceTypePrimary)
				if nvdSeverity != defs.SeverityCodeUnknown {
					saved.Score.Global.Severity = nvdSeverity
					saved.Score.Global.Version = nvdVersion
					saved.Score.Global.Score = nvdScore
				}
				// Score NVD
				if ok, score40 := raw.GetCVSSV4(defs.SourceTypePrimary); ok {
					saved.Score.CVSS4 = *score40
				}
				if ok, score31 := raw.GetCVSSV3(defs.SourceTypePrimary); ok {
					saved.Score.CVSS3 = *score31
				}
				if ok, score20 := raw.GetCVSSV2(defs.SourceTypePrimary); ok {
					saved.Score.CVSS2 = *score20
				}
				// Socre VTI
				saved.Score.VTI.Version = defs.VersionVcs10

				if len(saved.Languages) == 0 {
					saved.Languages = []string{defs.LangEn}
				}
				// Send document to logstash-cve-queue
				cveRaw := raw.VulnerabilityToCVERaw()
				metaRaw := &model.CVERawLogstash{
					CVERaw: cveRaw,
					Metadata: model.Metadata{
						ID:    raw.GetID(),
						Index: defs.IndexCVERaw,
						Type:  defs.TypeCveRaw,
					},
				}
				metaBts, _ := json.Marshal(metaRaw)
				if err := worker.queue.Publish("", defs.QueueLogstashCveRaw, rabbit.Message{
					Body:        metaBts,
					ContentType: rabbit.MIMEApplicationJSON,
					Mode:        rabbit.Persistent,
					Priority:    0,
				}); err != nil {
					worker.logger.Errorf("[recheck]send CVE (%s) to logstash cve raw queue error, reason: %v", cveRaw.Detail.Metadata.ID, err)
					continue
				}

				// meta := &model.CVELogstash{
				// 	CVE: *saved,
				// 	Metadata: model.Metadata{
				// 		ID:    saved.ID,
				// 		Index: defs.IndexCVE,
				// 		Type:  defs.TypeCve,
				// 	},
				// }
				// metaBts, _ = json.Marshal(meta)
				// if err := queue.Publish("", defs.QueueLogstashCve, rabbit.Message{
				// 	Body:        metaBts,
				// 	ContentType: rabbit.MIMEApplicationJSON,
				// 	Mode:        rabbit.Persistent,
				// 	Priority:    0,
				// }); err != nil {
				// 	worker.logger.Errorf("[recheck]publish metaBts to QueueLogstashCve error, reason: %v", err)
				// 	continue
				// }
				// worker.logger.Infof("[recheck]publish metaBts to QueueLogstashCve")
				// Send language to logstash-cve-queue
				metaLang := &model.CVELangLogstash{
					CVELang: *lang,
					Metadata: model.Metadata{
						ID:    lang.ID,
						Index: fmt.Sprintf(defs.IndexCVELang, defs.LangEn),
						Type:  defs.TypeCve,
					},
				}
				metaLangBts, _ := json.Marshal(metaLang)
				if err := queue.Publish("", defs.QueueLogstashCve, rabbit.Message{
					Body:        metaLangBts,
					ContentType: rabbit.MIMEApplicationJSON,
					Mode:        rabbit.Persistent,
					Priority:    0,
				}); err != nil {
					worker.logger.Errorf("[recheck]publish metaLangBts to QueueLogstashCve error, reason: %v", err)
					continue
				}
				// if saved.Status == defs.StatusCodeUnknown {
				// 	if err := insertVtiLifeCycle(worker.elastic.CVELifecycle(), model.CVE_EVENT_CREATE_CVE, saved.Name, saved.Created); err != nil {
				// 		worker.logger.Errorf("insertVtiLifeCycle CVE_EVENT_CREATE_CVE error, reason: %v", err)
				// 	} else {
				// 		worker.logger.Infof("insertVtiLifeCycle %s success, event: %v", saved.Name, model.CVE_EVENT_CREATE_CVE)
				// 	}
				// }
				// Send cve-analyzer-queue
				dataBts, _ := json.Marshal(saved)
				if err := queue.Publish("", defs.QueueCveAnalyzer, rabbit.Message{
					Body:        dataBts,
					ContentType: rabbit.MIMEApplicationJSON,
					Mode:        rabbit.Persistent,
					Priority:    0,
				}); err != nil {
					worker.logger.Errorf("[recheck]publish CVE to QueueCveAnalyzer error, reason: %v", err)
					continue
				}
			}
			// delay
			now, _ = clock.Now(clock.UTC)
			next := now.Add(time.Duration(delay))
			worker.logger.Infof("next time recheck: %s", clock.Format(next, clock.FormatHumanZ))
			clock.Sleep(delay)
		}
	})

}
func (worker *cveRecheck) Prepare() {
	if err := worker.queue.DeclareQueue(defs.QueueCveMapping, true, 0, 0); err != nil {
		panic(err)
	}
}

func (worker *cveRecheck) GetCVE(id string) (*model.CVEAPI, error) {
	res, err := worker.client.R().
		SetHeader("apiKey", worker.config.NVDKey).
		Get(fmt.Sprintf(worker.config.NVDApi, id))
	if err != nil {
		worker.logger.Errorf("get url (%s) error, reason: %v", worker.config.NVDApi, err)
		return nil, err
	}
	if res.StatusCode() != rest.StatusOK {
		worker.logger.Errorf("get url (%s) return code %d", fmt.Sprintf(worker.config.NVDApi, id), res.StatusCode())
		return nil, errors.New(fmt.Sprintf("status code: %d", res.StatusCode()))
	}

	var cve CVEResponse
	err = json.Unmarshal(res.Body(), &cve)
	if err != nil {
		worker.logger.Errorf("Unmarshal cve error, reason: %v", err)
		return nil, err
	}

	if len(cve.Vulnerabilities) == 0 {
		return nil, errors.New("not found")
	}

	return &cve.Vulnerabilities[0].CVE, nil
}

type CVEResponse struct {
	Vulnerabilities []CVE `json:"vulnerabilities"`
	StartIndex      int   `json:"startIndex"`
	TotalResults    int   `json:"totalResults"`
	ResultsPerPage  int   `json:"resultsPerPage"`
}

type CVE struct {
	CVE model.CVEAPI `json:"cve"`
}
