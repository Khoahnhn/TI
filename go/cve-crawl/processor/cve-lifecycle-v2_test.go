package processor

import (
	"context"
	"cve-crawler/mocks"
	"cve-crawler/model"
	"errors"
	"os"
	"testing"

	"gitlab.viettelcyber.com/awesome-threat/library/adapter/rabbit"
	"go.uber.org/mock/gomock"
	"gopkg.in/yaml.v2"
)

func Test_cveLifecycleV2_Start(t *testing.T) {
	ctrl := gomock.NewController(t)
	err := errors.New("foo")

	tests := []struct {
		name   string
		worker *cveLifecycleV2
	}{
		{
			name: "base_case",
			worker: func() *cveLifecycleV2 {
				ctx, cancel := context.WithCancel(context.Background())
				mockRabbit := mocks.NewMockService(ctrl)
				mockKafka := mocks.NewMockConsumer(ctrl)

				mockRabbit.EXPECT().
					DeclareQueue(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().Return(nil)

				mockRabbit.EXPECT().
					Consume(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Do(func(queue string, auto bool, prefetchCount int, callback rabbit.Consumer) {
						cancel()
					}).Return(nil)

				mockKafka.EXPECT().Close().AnyTimes()
				return &cveLifecycleV2{
					context:       ctx,
					queue:         mockRabbit,
					kafkaConsumer: mockKafka,
				}
			}(),
		},
		{
			name: "rabbit_error_case",
			worker: func() *cveLifecycleV2 {
				ctx, cancel := context.WithCancel(context.Background())
				mockRabbit := mocks.NewMockService(ctrl)
				mockKafka := mocks.NewMockConsumer(ctrl)

				mockRabbit.EXPECT().
					DeclareQueue(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().Return(nil)

				mockRabbit.EXPECT().
					Consume(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Do(func(queue string, auto bool, prefetchCount int, callback rabbit.Consumer) {
						cancel()
					}).Return(err)

				mockKafka.EXPECT().Close().AnyTimes()
				return &cveLifecycleV2{
					context:       ctx,
					queue:         mockRabbit,
					kafkaConsumer: mockKafka,
				}
			}(),
		},
		{
			name: "cve_raw_err_case",
			worker: func() *cveLifecycleV2 {
				ctx, cancel := context.WithCancel(context.Background())
				mockRabbit := mocks.NewMockService(ctrl)
				mockKafka := mocks.NewMockConsumer(ctrl)
				mockElastic := mocks.NewMockEnrichmentRepository(ctrl)

				mockRabbit.EXPECT().
					DeclareQueue(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().Return(nil)

				mockRabbit.EXPECT().
					Consume(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Do(func(queue string, auto bool, prefetchCount int, callback rabbit.Consumer) {
						callback([]byte("CVE-0-0"))
						cancel()
					}).
					Return(nil)

				mockCVERaw := mocks.NewMockCVERawRepository(ctrl)
				mockElastic.EXPECT().CVERaw().AnyTimes().Return(mockCVERaw)

				mockCVERaw.EXPECT().
					Find(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(nil, err)

				mockKafka.EXPECT().Close().AnyTimes()
				return &cveLifecycleV2{
					context:       ctx,
					queue:         mockRabbit,
					kafkaConsumer: mockKafka,
					elastic:       mockElastic,
				}
			}(),
		},
		{
			name: "cve_raw_no_doc_case",
			worker: func() *cveLifecycleV2 {
				ctx, cancel := context.WithCancel(context.Background())
				mockRabbit := mocks.NewMockService(ctrl)
				mockKafka := mocks.NewMockConsumer(ctrl)
				mockElastic := mocks.NewMockEnrichmentRepository(ctrl)

				mockRabbit.EXPECT().
					DeclareQueue(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().Return(nil)

				mockRabbit.EXPECT().
					Consume(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Do(func(queue string, auto bool, prefetchCount int, callback rabbit.Consumer) {
						callback([]byte("CVE-0-0"))
						cancel()
					}).
					Return(nil)

				mockCVERaw := mocks.NewMockCVERawRepository(ctrl)
				mockElastic.EXPECT().CVERaw().AnyTimes().Return(mockCVERaw)

				mockCVERaw.EXPECT().
					Find(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(nil, nil)

				mockKafka.EXPECT().Close().AnyTimes()
				return &cveLifecycleV2{
					context:       ctx,
					queue:         mockRabbit,
					kafkaConsumer: mockKafka,
					elastic:       mockElastic,
				}
			}(),
		},
		{
			name: "cve_raw_bad_time_case",
			worker: func() *cveLifecycleV2 {
				ctx, cancel := context.WithCancel(context.Background())
				mockRabbit := mocks.NewMockService(ctrl)
				mockKafka := mocks.NewMockConsumer(ctrl)
				mockElastic := mocks.NewMockEnrichmentRepository(ctrl)

				mockRabbit.EXPECT().
					DeclareQueue(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().Return(nil)

				mockRabbit.EXPECT().
					Consume(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Do(func(queue string, auto bool, prefetchCount int, callback rabbit.Consumer) {
						callback([]byte("CVE-0-0"))
						cancel()
					}).
					Return(nil)

				mockRabbit.EXPECT().
					Publish(gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(nil)

				mockCVERaw := mocks.NewMockCVERawRepository(ctrl)
				mockElastic.EXPECT().CVERaw().AnyTimes().Return(mockCVERaw)

				returnedRaw := []*model.CVERaw{
					{
						PublishedDate: "malformed",
					},
				}
				mockCVERaw.EXPECT().
					Find(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(returnedRaw, nil)

				mockKafka.EXPECT().Close().AnyTimes()
				return &cveLifecycleV2{
					context:       ctx,
					queue:         mockRabbit,
					kafkaConsumer: mockKafka,
					elastic:       mockElastic,
				}
			}(),
		},
		{
			name: "cve_raw_happy_case",
			worker: func() *cveLifecycleV2 {
				ctx, cancel := context.WithCancel(context.Background())
				mockRabbit := mocks.NewMockService(ctrl)
				mockKafka := mocks.NewMockConsumer(ctrl)
				mockElastic := mocks.NewMockEnrichmentRepository(ctrl)

				mockRabbit.EXPECT().
					DeclareQueue(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().Return(nil)

				mockRabbit.EXPECT().
					Consume(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Do(func(queue string, auto bool, prefetchCount int, callback rabbit.Consumer) {
						callback([]byte("CVE-0-0"))
						cancel()
					}).
					Return(nil)

				mockRabbit.EXPECT().
					Publish(gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(nil)

				mockCVERaw := mocks.NewMockCVERawRepository(ctrl)
				mockElastic.EXPECT().CVERaw().AnyTimes().Return(mockCVERaw)

				returnedRaw := []*model.CVERaw{
					{
						PublishedDate: "2011-11-11T11:11:11.111",
						Detail: model.CVEDetail{
							References: model.CVEReference{
								Data: []model.CVEReferenceData{
									{
										Url: "http://[::1",
									},
									{
										Url: "http://example.com",
									},
									{
										Url:  "http://github.com",
										Tags: []string{"Vendor Advisory"},
									},
								},
							},
						},
					},
				}
				mockCVERaw.EXPECT().
					Find(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(returnedRaw, nil)

				mockKafka.EXPECT().Close().AnyTimes()
				return &cveLifecycleV2{
					context:       ctx,
					queue:         mockRabbit,
					kafkaConsumer: mockKafka,
					elastic:       mockElastic,
				}
			}(),
		},
		{
			name: "cve_raw_publish_fail_case",
			worker: func() *cveLifecycleV2 {
				ctx, cancel := context.WithCancel(context.Background())
				mockRabbit := mocks.NewMockService(ctrl)
				mockKafka := mocks.NewMockConsumer(ctrl)
				mockElastic := mocks.NewMockEnrichmentRepository(ctrl)

				mockRabbit.EXPECT().
					DeclareQueue(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().Return(nil)

				mockRabbit.EXPECT().
					Consume(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Do(func(queue string, auto bool, prefetchCount int, callback rabbit.Consumer) {
						callback([]byte("CVE-0-0"))
						cancel()
					}).
					Return(nil)

				mockRabbit.EXPECT().
					Publish(gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(err)

				mockCVERaw := mocks.NewMockCVERawRepository(ctrl)
				mockElastic.EXPECT().CVERaw().AnyTimes().Return(mockCVERaw)

				returnedRaw := []*model.CVERaw{
					{
						PublishedDate: "2011-11-11T11:11:11.111",
						Detail: model.CVEDetail{
							References: model.CVEReference{
								Data: []model.CVEReferenceData{
									{
										Url:  "http://github.com",
										Tags: []string{"Vendor Advisory"},
									},
								},
							},
						},
					},
				}
				mockCVERaw.EXPECT().
					Find(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
					AnyTimes().
					Return(returnedRaw, nil)

				mockKafka.EXPECT().Close().AnyTimes()
				return &cveLifecycleV2{
					context:       ctx,
					queue:         mockRabbit,
					kafkaConsumer: mockKafka,
					elastic:       mockElastic,
				}
			}(),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.worker.outputEventChan = make(chan *model.CVELifecycle)
			tt.worker.Start()
		})
	}
}

func Test_cveLifecycleV2_handleKafkaMessage(t *testing.T) {
	conf := model.WorkerConfig{
		Adapter: model.AdapterConfig{
			Kafka: model.KafkaConfig{
				Topic: model.KafkaTopicConfig{
					VulPriorityCisa:   "cisa",
					CVELifecycleInput: "ost",
				},
			},
		},
	}
	type args struct {
		topic string
		in1   []byte
		value []byte
	}
	tests := []struct {
		name    string
		worker  *cveLifecycleV2
		args    args
		wantErr bool
	}{
		{
			name:   "cisa_fail_case",
			worker: &cveLifecycleV2{},
			args: func() args {
				return args{
					topic: "cisa",
					value: []byte("malformed"),
				}
			}(),
			wantErr: false,
		},
		{
			name:   "cisa_bad_date_case",
			worker: &cveLifecycleV2{},
			args: func() args {
				return args{
					topic: "cisa",
					value: []byte(`
					{
						"dateAdded": "when",
						"cve": "CVE-0-0"
					}
					`),
				}
			}(),
			wantErr: false,
		},
		{
			name:   "cisa_happy_case",
			worker: &cveLifecycleV2{},
			args: func() args {
				return args{
					topic: "cisa",
					value: []byte(`
					{
						"dateAdded": "2011-11-11",
						"cve": "CVE-0-0"
					}
					`),
				}
			}(),
			wantErr: false,
		},
		{
			name:   "ost_fail_case",
			worker: &cveLifecycleV2{},
			args: func() args {
				return args{
					topic: "ost",
					value: []byte("malformed"),
				}
			}(),
			wantErr: false,
		},
		{
			name:   "ost_bad_date_case",
			worker: &cveLifecycleV2{},
			args: func() args {
				return args{
					topic: "ost",
					value: []byte(`
					{
						"publishDate": 0,
						"cve": "CVE-0-0"
					}
					`),
				}
			}(),
			wantErr: false,
		},
		{
			name:   "ost_happy_case",
			worker: &cveLifecycleV2{},
			args: func() args {
				return args{
					topic: "ost",
					value: []byte(`
					{
						"publishDate": 1,
						"cve": "CVE-0-0"
					}
					`),
				}
			}(),
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.worker.outputEventChan = make(chan *model.CVELifecycle, 10)
			tt.worker.config = conf
			if err := tt.worker.handleKafkaMessage(tt.args.topic, tt.args.in1, tt.args.value); (err != nil) != tt.wantErr {
				t.Errorf("cveLifecycleV2.handleKafkaMessage() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_newCveLifecycleV2(t *testing.T) {
	var config model.WorkerConfig
	f, err := os.Open("../config-dev.yaml")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	decoder := yaml.NewDecoder(f)
	err = decoder.Decode(&config)
	if err != nil {
		panic(err)
	}
	newCveLifecycle(context.TODO(), config)
}
