package processor

import (
	"bytes"
	"context"
	"cve-crawler/defs"
	"cve-crawler/mocks"
	mocksRedis "cve-crawler/mocks/mock_redis"
	"cve-crawler/model"
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"os"
	"testing"
	"time"

	"github.com/go-resty/resty/v2"
	"gitlab.viettelcyber.com/awesome-threat/library/log/pencil"
	"go.uber.org/mock/gomock"
	"golang.org/x/time/rate"
	"gopkg.in/yaml.v2"
)

func TestNewCveEpssJob(t *testing.T) {
	var config model.WorkerConfig
	f, err := os.Open("../config-dev.yaml")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	decoder := yaml.NewDecoder(f)
	err = decoder.Decode(&config)
	if err != nil {
		panic(err)
	}
	NewCveEpssJob(context.TODO(), config)
}

type fakeTransportEpss struct {
	page *model.FirstOrgCveEpssResponse
}

func (t *fakeTransportEpss) RoundTrip(req *http.Request) (*http.Response, error) {
	var msg []byte

	if t.page == nil {
		msg, _ = json.Marshal(model.FirstOrgCveEpssResponse{})
	} else {
		msg, _ = json.Marshal(t.page)
		t.page = nil
	}

	return &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(bytes.NewBufferString(string(msg))),
		Header:     make(http.Header),
	}, nil
}

func TestCveEpssJob_RunJob(t *testing.T) {
	// ctrl := gomock.NewController(t)
	logger, _ := pencil.New(defs.WorkerCveParser, pencil.DebugLevel, false, os.Stdout)

	tests := []struct {
		name    string
		j       *CveEpssJob
		wantErr bool
	}{
		{
			name: "base_case",
			j: func() *CveEpssJob {
				limiter := rate.NewLimiter(rate.Inf, 0)

				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransportEpss{})

				jobsChan := make(chan []*model.FirstOrgCveEpssData, 2)

				return &CveEpssJob{
					Client:      mockResty,
					RateLimiter: limiter,
					JobsChan:    jobsChan,
				}
			}(),
			wantErr: false,
		},
		{
			name: "data_case",
			j: func() *CveEpssJob {
				limiter := rate.NewLimiter(rate.Inf, 0)

				mockResty := resty.New()
				mockResty.SetTransport(&fakeTransportEpss{
					page: &model.FirstOrgCveEpssResponse{
						Data: []*model.FirstOrgCveEpssData{
							{
								Epss: "abc",
							},
						},
					},
				})

				jobsChan := make(chan []*model.FirstOrgCveEpssData, 2)

				return &CveEpssJob{
					Client:      mockResty,
					RateLimiter: limiter,
					JobsChan:    jobsChan,
				}
			}(),
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx, cancel := context.WithCancel(context.Background())
			tt.j.Logger = logger
			tt.j.Context = ctx
			go func() {
				time.Sleep(2 * time.Second)
				close(tt.j.JobsChan)
				cancel()
			}()
			if err := tt.j.RunJob(); (err != nil) != tt.wantErr {
				t.Errorf("CveEpssJob.RunJob() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestCveEpssJob_ProcessEpssBatch(t *testing.T) {
	ctrl := gomock.NewController(t)
	err := errors.New("foo")
	logger, _ := pencil.New(defs.WorkerCveParser, pencil.DebugLevel, false, os.Stdout)
	type args struct {
		ctx   context.Context
		batch []*model.FirstOrgCveEpssData
	}
	tests := []struct {
		name    string
		j       *CveEpssJob
		args    args
		wantErr bool
	}{
		{
			name: "batch_empty_case",
			j:    &CveEpssJob{},
			args: args{
				ctx:   context.TODO(),
				batch: []*model.FirstOrgCveEpssData{},
			},
			wantErr: false,
		},
		{
			name: "cache_error_case",
			j: func() *CveEpssJob {
				mockRedis := mocksRedis.NewMockService(ctrl)
				mockRedisString := mocksRedis.NewMockStrings(ctrl)

				mockRedis.EXPECT().Strings().Return(mockRedisString).AnyTimes()
				mockRedisString.EXPECT().
					Get(gomock.Any()).
					Return("", err).AnyTimes()

				return &CveEpssJob{
					Cache: mockRedis,
				}
			}(),
			args: args{
				ctx: context.TODO(),
				batch: []*model.FirstOrgCveEpssData{
					{
						Epss: "abc",
					},
					{
						Epss: "0.1",
					},
				},
			},
			wantErr: false,
		},
		{
			name: "no_cache_case",
			j: func() *CveEpssJob {
				mockRedis := mocksRedis.NewMockService(ctrl)
				mockRedisString := mocksRedis.NewMockStrings(ctrl)

				mockRedis.EXPECT().Strings().Return(mockRedisString).AnyTimes()
				mockRedisString.EXPECT().
					Get(gomock.Any()).
					Return("", nil).AnyTimes()

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)

				mockEs.EXPECT().CVE().AnyTimes().Return(mockCve)
				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).
					Return(nil, err)

				return &CveEpssJob{
					Cache:   mockRedis,
					Elastic: mockEs,
				}
			}(),
			args: args{
				ctx: context.TODO(),
				batch: []*model.FirstOrgCveEpssData{
					{
						Epss: "abc",
					},
					{
						Epss: "0.1",
					},
				},
			},
			wantErr: false,
		},
		{
			name: "no_cache_case_empty_cve",
			j: func() *CveEpssJob {
				mockRedis := mocksRedis.NewMockService(ctrl)
				mockRedisString := mocksRedis.NewMockStrings(ctrl)

				mockRedis.EXPECT().Strings().Return(mockRedisString).AnyTimes()
				mockRedisString.EXPECT().
					Get(gomock.Any()).
					Return("", nil).AnyTimes()

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)

				mockEs.EXPECT().CVE().AnyTimes().Return(mockCve)
				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).
					Return(nil, nil)

				return &CveEpssJob{
					Cache:   mockRedis,
					Elastic: mockEs,
				}
			}(),
			args: args{
				ctx: context.TODO(),
				batch: []*model.FirstOrgCveEpssData{
					{
						Epss: "abc",
					},
					{
						Epss: "0.1",
					},
				},
			},
			wantErr: false,
		},
		{
			name: "no_cache_case_happy",
			j: func() *CveEpssJob {
				mockRedis := mocksRedis.NewMockService(ctrl)
				mockRedisString := mocksRedis.NewMockStrings(ctrl)

				mockRedis.EXPECT().Strings().Return(mockRedisString).AnyTimes()
				mockRedisString.EXPECT().
					Get(gomock.Any()).
					Return("", nil).AnyTimes()

				mockRedisString.EXPECT().
					Set(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(err).AnyTimes()

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)

				score := 0.2
				mockEs.EXPECT().CVE().AnyTimes().Return(mockCve)
				mockCve.EXPECT().GetByName(gomock.Any(), gomock.Any()).
					Return(&model.CVE{
						Epss: model.CVEEpss{
							Score: &score,
						},
					}, nil)

				return &CveEpssJob{
					Cache:   mockRedis,
					Elastic: mockEs,
				}
			}(),
			args: args{
				ctx: context.TODO(),
				batch: []*model.FirstOrgCveEpssData{
					{
						Epss: "abc",
					},
					{
						Epss: "0.1",
					},
				},
			},
			wantErr: false,
		},
		{
			name: "cached_case_bulk_failed",
			j: func() *CveEpssJob {
				mockRedis := mocksRedis.NewMockService(ctrl)
				mockRedisString := mocksRedis.NewMockStrings(ctrl)

				score := float64(0.2)
				cachedObj := CveEpssCache{
					ID:    "bar",
					Score: &score,
				}
				cachedBts, _ := json.Marshal(cachedObj)
				mockRedis.EXPECT().Strings().Return(mockRedisString).AnyTimes()
				mockRedisString.EXPECT().
					Get(gomock.Any()).
					Return(string(cachedBts), nil).AnyTimes()

				mockRedisString.EXPECT().
					Set(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(err).AnyTimes()

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)

				mockEs.EXPECT().CVE().AnyTimes().Return(mockCve)
				mockCve.EXPECT().
					UpdateMany(gomock.Any(), gomock.Any()).
					Return(err).AnyTimes()
				return &CveEpssJob{
					Cache:   mockRedis,
					Elastic: mockEs,
				}
			}(),
			args: args{
				ctx: context.TODO(),
				batch: []*model.FirstOrgCveEpssData{
					{
						Cve:        "CVE-0-0",
						Epss:       "0.1",
						Percentile: "0.1",
					},
				},
			},
			wantErr: true,
		},
		{
			name: "cached_case_bulk_failed_history",
			j: func() *CveEpssJob {
				mockRedis := mocksRedis.NewMockService(ctrl)
				mockRedisString := mocksRedis.NewMockStrings(ctrl)

				score := float64(0.2)
				cachedObj := CveEpssCache{
					ID:    "bar",
					Score: &score,
				}
				cachedBts, _ := json.Marshal(cachedObj)
				mockRedis.EXPECT().Strings().Return(mockRedisString).AnyTimes()
				mockRedisString.EXPECT().
					Get(gomock.Any()).
					Return(string(cachedBts), nil).AnyTimes()

				mockRedisString.EXPECT().
					Set(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(err).AnyTimes()

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)

				mockEs.EXPECT().CVE().AnyTimes().Return(mockCve)
				mockCve.EXPECT().
					UpdateMany(gomock.Any(), gomock.Any()).
					Return(nil).AnyTimes()

				mockEpssHistory := mocks.NewMockCVEEpssHistoryRepository(ctrl)
				mockEs.EXPECT().CVEEpssHistory().Return(mockEpssHistory).AnyTimes()

				mockEpssHistory.EXPECT().
					StoreAll(gomock.Any(), gomock.Any()).
					Return(err).AnyTimes()
				return &CveEpssJob{
					Cache:   mockRedis,
					Elastic: mockEs,
				}
			}(),
			args: args{
				ctx: context.TODO(),
				batch: []*model.FirstOrgCveEpssData{
					{
						Cve:        "CVE-0-0",
						Epss:       "0.1",
						Percentile: "0.1",
					},
				},
			},
			wantErr: true,
		},
		{
			name: "happy_case",
			j: func() *CveEpssJob {
				mockRedis := mocksRedis.NewMockService(ctrl)
				mockRedisString := mocksRedis.NewMockStrings(ctrl)

				score := float64(0.2)
				cachedObj := CveEpssCache{
					ID:    "bar",
					Score: &score,
				}
				cachedBts, _ := json.Marshal(cachedObj)
				mockRedis.EXPECT().Strings().Return(mockRedisString).AnyTimes()
				mockRedisString.EXPECT().
					Get(gomock.Any()).
					Return(string(cachedBts), nil).AnyTimes()

				mockRedisString.EXPECT().
					Set(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(err).AnyTimes()

				mockEs := mocks.NewMockEnrichmentRepository(ctrl)
				mockCve := mocks.NewMockCVERepository(ctrl)

				mockEs.EXPECT().CVE().AnyTimes().Return(mockCve)
				mockCve.EXPECT().
					UpdateMany(gomock.Any(), gomock.Any()).
					Return(nil).AnyTimes()

				mockEpssHistory := mocks.NewMockCVEEpssHistoryRepository(ctrl)
				mockEs.EXPECT().CVEEpssHistory().Return(mockEpssHistory).AnyTimes()

				mockEpssHistory.EXPECT().
					StoreAll(gomock.Any(), gomock.Any()).
					Return(nil).AnyTimes()
				return &CveEpssJob{
					Cache:   mockRedis,
					Elastic: mockEs,
				}
			}(),
			args: args{
				ctx: context.TODO(),
				batch: []*model.FirstOrgCveEpssData{
					{
						Cve:        "CVE-0-0",
						Epss:       "0.1",
						Percentile: "0.1",
					},
				},
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.j.Logger = logger
			if err := tt.j.ProcessEpssBatch(tt.args.ctx, tt.args.batch); (err != nil) != tt.wantErr {
				t.Errorf("CveEpssJob.ProcessEpssBatch() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestCveEpssJob_Start(t *testing.T) {
	ctx, cancel := context.WithCancel(context.TODO())
	logger, _ := pencil.New(defs.WorkerCveParser, pencil.DebugLevel, false, os.Stdout)
	worker := CveEpssJob{
		Context: ctx,
		Logger:  logger,
	}
	go func() {
		time.Sleep(2 * time.Second)
		cancel()
	}()

	worker.Start()
}
